'AVC3 CODE LIBRARY

'TRIVIAL BASE CASES SHOULD NOT BE SPECIALCASED, USE PRETESTED LOOPS TO ENSURE LEN=0 OR SIMILAR ARGUMENTS DO NOTHING

'SUBROUTINES SHOULD BE AS GENERALISED AS POSSIBLE, WITH HELPER SUBROUTINES TO ACHEIVE MORE SPECIALISED FUNCTIONALITY

'SUBROUTINES SHOULD USE AS LITTLE STACK SPACE AS POSSIBLE BY USING THE ? PREFIX WHEREVER PRACTICAL AND AVOIDING PRESERVATION

'LABELS MUST BE PRECEDED BY A NEWLINE

'@ PREFIX FOR ENTRYPOINTS
'_ PREFIX FOR SYSTEM VARIABLES
'ALL LOCAL VARIABLES OR ENTRYPOINTS MUST USE THEIR SUBROUTINE'S PREFIX

'TEMPLATE
'********

'SHORT DESCRIPTION
'ARGUMENTS
'-> RETURNS

':@NAME 'ABBREVIATION (NO DOTS)

*&HA000 'LIBRARY STARTS HERE
'VARIABLES

'TERMINAL
:_LOC ;LIB_END 'LOCATION
:_LEN &H300 'LENGTH
:_CR ;_CUR 'DEFAULT CURSOR
:_CUR 0 'START IN TOP CORNER
:_CRPC ! 'DEFAULT CURSOR
'KEYBOARD
:_KSC 1 'SPECIAL CHARACTER SELECTOR IS ON BY DEFAULT
:_Δ 12 'DEFAULT KEYBOARD SENSITIVITY
'PIXEL ENGINE
:_PIXEL_OFFSET ;LIB_END 'PIXEL SCREEN ADDRESS
'DEQUE
:_QLOC ;SCREEN_END 'START OF QUEUE
:_QEND &HE000 'END OF QUEUE
:_EQCUR ;SCREEN_END 'ENQUEUE CURSOR
:_DQCUR ;SCREEN_END 'DEQUEUE
'BASEPRINT
:_BASE 10 'DEFAULT BASE
'SPRITES
:_ORIGIN ;LIB_END 'SPRITE ORIGIN
:_SPLIMIT &H300 'SPRITE LIMIT


'BUFFERS
:WTN_LOC +16 'NUMBER BUFFER
:FILE +14 'FILENAME BUFFER
:IGD_SIGN '4W-INT BUFFER
!- 'NEGATIVE SIGN, IF NECESSARY
:IGD_LOC
+&H48 'LEAVE SPACE FOR ALL DIGITS


'NUMBER REGISTERS
>IDM_N 0 0 0 0 'NUMERATOR
>IDM_D 0 0 0 0 'DIVISOR

>IM_S7 'START OF SCRATCH REGISTER
0
>IM_S6
0
>IM_S5
0
>IM_S4
0
>IM_S3
0
>IM_S2
0
>IM_S1
0
>IM_S0
0



























'LOCATION-LENGTH TO START-END
'LOCATION, LENGTH
'-> START, END

:@LL_SE
ADDR .11 ,11 .11 % 'ADD LOCATION TO LENGTH
]

'START-END TO LOCATION-LENGTH
'START, END
'-> LOCATION, LENGTH

:@SE_LL
SUBR ?1 .11 = % 'SUB START FROM END
]

'FORWARDS COPY
'LOCATION, LENGTH, DESTINATION
'->

:@FCP
MCOPYR ?2 ?1 ?0 'RUN MCOPY
ADDI 3 11 = % 'DISPOSE OF ARGUMENTS
]

'BACKWARDS COPY
'LOCATION, LENGTH, DESTINATION
'->

:@BCP
'SWAP ?0 ?2 'SWAP LOCATION AND DESTINATION
ADDR ?1 ?0 = % 'OFFSET BOTH BY LENGTH
ADDR ?1 ?2 = %
TWO ?1 = 'INVERT LENGTH
JUMP ;@FCP 'COPY!

'FILLER
'LOCATION, LENGTH, FILLER BYTE
'->
:@FILL
MFILLR ?2 ?1 ?0 'RUN MFILL
ADDI 3 11 = % 'DISPOSE OF ARGUMENTS
]

'ERASE
'LOCATION, LENGTH
'->
:@ERASE
I 0
JUMP ;@FILL

'GET TOUCH
'-> X, Y, T

:@TOUCH
TOUCH .11 = =
]

'GET TOUCH CHARACTERS
'X, Y, T
'-> CX, CY, T

:@TCHAR
DIVI 8 ?1 = = 'Y/8
DIVI 8 ?2 = = 'X/8
]

'GET MEMORY ADDRESS FROM TOUCH COORDINATE
'CX, CY, T
'-> ADDRESS, BEZEL?, TIME

:@TADDRESS
PR &B1111 &B1011
'R0=X
'R1=Y
'R3=T

'SUB OFFSETS FROM X AND Y
SUBI 4 0 = %
SUBI 3 1 = %

'CHECK FOR SETTING OVERFLOW FLAG
JLI+ &H1F 0 <TA_OVSET
JLI+ &H17 1 <TA_OVSET

>OV_RESET
MOVE 0 2 'OV=0
JUMP <TA_EXIT

>TA_OVSET
MOVE 1 2 'OV=1

>TA_EXIT
MULI &H20 1 = = 'Y*32
ADDR 1 0 = % 'ADD TO X
ADDR 14 0 = % 'ADD SCREEN OFFSET

SRE &B1101 &B1111

'VALIDATE A TOUCH
'BEZEL?, T
'-> VALID?

:@TVALID
TRUE ,11 = 'SIMPLIFY TIME
XORI 1 ?1 = 'INVERT BEZEL
ANDR .11 = = 'AND TOGETHER ~BEZEL & TIME?
]

'REQUIRE TOUCH
'->
:@RTOUCH 'RT
'GET TOUCH
>RT_LOOP
TOUCH % % .11
JEI 0 .11 <RT_LOOP
]

'GET A VALID TOUCH
'-> ADDRESS, VALID?

:@@TOUCH
;@TOUCH
;@TCHAR
;@TADDRESS
;@TVALID
]

'GET BUTTON INPUT UNTIL ALL BUTTONS RELEASED
'-> BUTTON#
:@BTN 'BT
PSR 0 'R0=BUTTON PRESSED
I 0 'TEMP VALUE STORING BUTTONS PRESSED

>BT_LOOP
BUTTON 0 'GET BUTTON PRESSED
ORR 0 ,11 = 'OR INTO VALUE
JNI 0 0 <BT_LOOP 'REPEAT UNTIL BUTTONS ARE RELEASED
SRE &B0 &B1


'REQUIRE BUTTON PRESS
'-> COMPLETE BUTTON STATE
'WAITS UNTIL A BUTTON IS PRESSED AND ALL BUTTONS ARE RELEASED

:@RBTN 'RB

>RB_LOOP
;@BTN
JEI 0 .11 <RB_LOOP 'REPEAT UNTIL NONZERO
DEC 11 'RESTORE POPPED VALUE!
]

'UNIVERSAL MEMORY SEARCH
'LOCATION, ITERATIONS, SEARCH BYTE, REPEAT COUNT, ANTIFIND FLAG, INCREMENT
'-> CHARACTER POSITION, SUCCESS FLAG

:@UMS
'-
'REPEAT COUNT N SPECIFIES THAT THE NTH MATCHING CHARACTER'S POSITION SHOULD BE RETURNED
'ALL REPEAT COUNT OF ZERO SEARCHES FAIL
'-
'THE ANTIFIND FLAG BEING NONZERO SPECIFIES THAT THE SEARCH IS FOR EVERYTHING BUT THE SEARCH BYTE.
'-
PR &B1111111 &B111111
'R0=LOCATION POINTER
'R1=ITERATION
'R2=SEARCH BYTE
'R3=REPEAT COUNT
'R4=ANTIFIND FLAG
'R5=INCREMENT
'R6=TEMP RESULT
'R7=SCRATCH

>UMS_LOOP
JEI 0 3 <UMS_GOOD 'SEARCH COMPLETE?
JEI 0 (1 <UMS_BAD 'SEARCH FAILED? ITER--
JNI 0 4 <UMS_ANTI 'ANTIFINDER?
JER 2 ,0 <UMS_HIT 'SEARCH "HIT"?

>UMS_LOWLOOP 'LOWER LOOP SECTION
ADDR 5 0 = % 'ADD INCREMENT
JUMP <UMS_LOOP 'REPEAT

>UMS_ANTI
JNR 2 ,0 <UMS_HIT 'SEARCH "HIT"?
JUMP <UMS_LOWLOOP

>UMS_HIT
COPY 0 6 'UPDATE TEMP RESULT
DEC 3 'REPEAT COUNT--
JUMP <UMS_LOWLOOP

>UMS_BAD
MOVE 0 1
JUMP <UMS_EXIT

>UMS_GOOD
MOVE 1 1

>UMS_EXIT
COPY 6 0
SRE &B11 &B1111111

'SIMPLE FORWARD SEARCH
'PARAMETERS: LOCATION, ITERATIONS, SEARCH BYTE
'RETURNS: CHARACTER POSITION, SUCCESS FLAG

:@SFFIND
I 1 'REPEAT COUNT

'ADVANCED FORWARD SEARCH
'PARAMETERS: LOCATION, ITERATIONS, SEARCH BYTE, REPEAT COUNT
'RETURNS: CHARACTER POSITION, SUCCESS FLAG

:@AFFIND
I 0 'ANTIFIND OFF
I 1 'INCREMENT BY ONE
;@UMS 'SEARCH
]

'SIMPLE FORWARD ANTISEARCH
'PARAMETERS: LOCATION, ITERATIONS, SEARCH BYTE
'RETURNS: CHARACTER POSITION, SUCCESS FLAG

:@SFAFIND
I 1 'REPEAT COUNT

'ADVANCED FORWARD ANTISEARCH
'PARAMETERS: LOCATION, ITERATIONS, SEARCH BYTE, REPEAT COUNT
'RETURNS: CHARACTER POSITION, SUCCESS FLAG

:@AFAFIND
I 1 'ANTIFIND ON
I 1 'INCREMENT BY ONE
;@UMS 'SEARCH
]

'SIMPLE BACKWARD SEARCH
'PARAMETERS: LOCATION, ITERATIONS, SEARCH BYTE
'RETURNS: CHARACTER POSITION, SUCCESS FLAG

:@SBFIND
I 1 'REPEAT COUNT

'ADVANCED BACKWARD SEARCH
'PARAMETERS: LOCATION, ITERATIONS, SEARCH BYTE, REPEAT COUNT
'RETURNS: CHARACTER POSITION, SUCCESS FLAG

:@ABFIND
I 0 'ANTIFIND OFF
I -1 'INCREMENT BY MINUS ONE
;@UMS 'SEARCH
]

'SIMPLE BACKWARD ANTISEARCH
'PARAMETERS: LOCATION, ITERATIONS, SEARCH BYTE
'RETURNS: CHARACTER POSITION, SUCCESS FLAG

:@SBAFIND
I 1 'REPEAT COUNT

'ADVANCED BACKWARD ANTISEARCH
'PARAMETERS: LOCATION, ITERATIONS, SEARCH BYTE, REPEAT COUNT
'RETURNS: CHARACTER POSITION, SUCCESS FLAG

:@ABAFIND
I 1 'ANTIFIND ON
I -1 'INCREMENT BY MINUS ONE
;@UMS 'SEARCH
]

'SET UP DISPLAY WITH TERMINAL ON TOP

:@13
MOVE ;LIB_END 13
]

'SET UP DISPLAY WITH KEYBOARD ON BOTTOM
:@14
MOVE ;KB_KEYS 14
]

:@34
;@13
;@14
]

'PUT CHARACTER TO THE DEFAULT TERMINAL
'CHARACTER
'->

:@PC 'PC
R ;_LOC 'PUSH LOCATION
R ;_LEN 'PUSH LENGTH
R ;_CR 'PUSH CURSOR
;@TERMINAL 'CALL TERMINAL
'REFR';:;:;:
]


'PUT CHARACTER TO A TERMINAL
'CURSOR IS NOW OFFSET FROM LOC

'CHAR, LOC, LEN, CURSOR
'->

:@TERMINAL 'TM
PR &B1111 &B1111

'R0=CHAR
'R1=LOC
'R2=LEN
'R3=CURSOR

>TM_START 'RESTART POINT
JLR+ ,3 2 <TM_OK 'CURSOR IN RANGE?

'SCROLL UP
ADDI &H20 1 .11 % 'SOURCE LOC
SUBI &H20 2 .11 % 'SOURCE LEN
R 1 'DEST LOC
;@FCP 'COPY

'ERASE REMAINING LINE LOC+LEN-&H20
ADDR 1 2 .11 % 'LOC+LEN
SUBI &H20 ,11 = % 'SUB &H20
I &H20
;@ERASE

SUBI &H20 ,3 = % 'SUB CURSOR
JUMP <TM_START 'RESTART

>TM_OK
JEI 8 0 <TM_DEL 'DELETE?

'"PRINTABLE" CHARACTER
RSTORER 0 1 ,3 'PRINT
JEI 10 0 <TM_ENTER 'ENTER?
INC ,3 'ADVANCE THE CURSOR

EXIT &B1111

>TM_ENTER
ANDI &B1111111111100000 ,3 = 'ERASE LOW BITS OF CURSOR
ADDI &H20 ,3 = % 'MOVE ONTO NEW LINE

EXIT &B1111

>TM_DEL
'LOOK BACKWARDS FOR NON-NULL FROM CURSOR
ADDR 1 ,3 .11 % 'LOC+CUR LOCATION
DEC ,11 'SEARCH FROM LOC+CUR-1
R ,3 'ITERATIONS
I 0 'SEARCH BYTE
;@SBAFIND 'SEARCH BACKWARDS
JEI 0 .11 <TM_SF 'SEARCH FAIL?
STOREIR 0 ,11 'ERASE CHR
SUBR 1 .11 ,3 % 'CORRECT NEW POSITION
EXIT &B1111

>TM_SF
'AT START OF GRID, NOTHING TO DO
INC 11
EXIT &B1111

'INTEGER TO DIGIT
'INTEGER
'-> UNICODE CHARACTER FOR DIGIT

:@I_D 'I_D
ADDI !0 .11 = % 'ADD 0
JGI+ !: ,11 <I_D_9+ 'GREATER THAN NINE?
ADDI 7 ,11 = % 'ADD EXTENDED BASE OFFSET

>I_D_9+
] 'SEND DIGIT

'DIGIT TO INTEGER
'DIGIT
'-> INTEGER

:@D_I
SUBI !0 .11 = % 'SUB 0
JGI+ 10 ,11 <I_D_9+ 'GREATER THAN NINE?
SUBI 7 .11 = % 'SUB EXTENDED BASE OFFSET
]

'BLOCKFINDER
'FINDS NULL-TERMINATED BLOCKS
'LOCATION
'-> LOCATION, LENGTH OF BLOCK

:@BLOCK
;@COPY 'LOC, LOC
;@FINDNULL 'LOC, NULL LOC
;@SE_LL 'COVERT TO RESULT
]

'BLOCKFINDER 2
'FINDS CUSTOM BLOCKS
'LOCATION, END CHR
'-> LOCATION, LENGTH OF BLOCK

:@BLOCK2
PR &B11 &B11
R 0 'LOC
I -1 'LEN
R 1 'END
;@SFFIND 'FIND END CHR
;@X 'DISCARD SUCCESS FLAG
G 1 'GET END
SUBR 0 1 = % 'SUB START FROM END
SRE &B11 &B11



'FINDNULL
'PARAMETER: LOCATION
'RETURNS: LOCATION

:@FINDNULL 'LOC
I -1 'LOC, LEN
I 0 'LOC, LEN, 0
;@SFFIND ;@X 'RESULT
]


'MASS PRINT A STRING
'LOCATION, LENGTH
'->

:@MPRINT 'MP
PR &B11 &B11

>MP_LOOP 'MAIN LOOP
JEI 0 (1 <MP_EXIT 'EXIT?
R .0 'PUSH CHR
;@PC 'PRINT IT
JUMP <MP_LOOP 'INC LOC AND RESTART

>MP_EXIT
EXIT &B11

'BLOCK PRINT (NO LONGER USED)
'PRINTS NULL-TERMINATED TEXT BLOCK
'LOCATION
'->

:@BPRINTL
;@BLOCK
;@MPRINT
]

'BLOCK PRINT
'PRINTS NULL-TERMINATED TEXT BLOCK
'LOCATION
'->

:@BPRINT '...BP
PR _0 _0 'GET LOCATION

>BP_LOOP
JEI 0 ,0 <BP_EXIT 'NULL YET?
R .0 'PUSH [R0]
;@PC 'PRINT
JUMP <BP_LOOP

>BP_EXIT
EXIT _0

'QUICK PRINT
'->

'PRINTS STRING IMMEDIATELY AFTER THE CALL
:@QPRINT
R ,12 'PUT STRING ON STACK
;@BPRINT 'BLOCK PRINT THE STRING
R ,12 'PUT STRING ON STACK
;@FINDNULL
ADDI 1 .11 ,12 % 'PUT ADDR AFTER NULL ON S12
]

'16-BIT INTEGER LIBRARY

'NUMBER LENGTH CALCULATOR
'BASE
'-> LENGTH
:@LENCALC 'LC
PR &B1111 &B1
MOVE 1 1 'MOVE CHECK NUMBER INTO R1
MOVE 0 3 'R3=DIGIT COUNTER

>LC_LOOP
MULR 0 1 2 1 'MULTIPLY BASE UP
INC 3 'COUNTER++
JEI 0 2 <LC_LOOP
SRE &B1000 &B1111

'WORD TO NUMBER, WITH LEADING ZEROES
'WORD, BASE
'-> LOCATION, LENGTH OF NUMBER
:@WORDTONUM 'WTN
PR &B111111 &B11
FUNC &B10 ;@LENCALC
'R0=WORD
'R1=BASE
COPY ,11 2 'R2=NUMBER OF DIGITS

'DIVIDE A NUMBER BY THE BASE, MOD RESULT IS THE DIGITS BACKWARD
'WRITE CURSOR NEEDS TO START AT BUFFER START+NUMLEN
ADDI ;WTN_LOC 2 3 % 'R3=DIGIT CURSOR

>WTN_LOOP
JEI 0 (2 <WTN_EXIT 'NO MORE DIGITS?
DIVR 1 0 .11 0 'GET REMAINDER
;@I_D 'CONVERT REMAINDER TO DIGIT
STORER .11 {3 'WRITE INTO THE BUFFER
JUMP <WTN_LOOP

>WTN_EXIT
'LENGTH IS ALREADY ON STACK
I ;WTN_LOC
SWAP .11 = 'SWAP FOR ORDER
EXIT &B111111

'CONVERT TEXT NUMBER TO WORD
'LOCATION, LENGTH, BASE
'-> WORD
:@NUMTOWORD 'NTW
PR &B1111 &B111
'R0=LOCATION
'R1=LENGTH
'R2=BASE
MOVE 0 3 'R3=NUMBER

>NTW_LOOP
JEI 0 (1 <NTW_EXIT 'NO MORE DIGITS?
MULR 2 3 = = 'MULTIPLY UP NUMBER
LOADR )0 .11 'GET DIGIT
;@D_I 'CONVERT DIGIT
ADDR .11 3 = % 'ADD IN DIGIT
JUMP <NTW_LOOP

>NTW_EXIT
SRE &B1000 &B1111



'CONVERT SB-FORMATTED NUMBER TO WORD
'LOCATION, LENGTH
'-> NUMBER

:@SBNUMTOWORD 'SBN
PR &B1111 &B11

'R0=LOCATION
'R1=LENGTH

JEI !& ,0 <SBN_OTHER 'OTHER BASES?
MOVE 10 2 'SET BASE TO DECIMAL

>SBN_EXIT
FUNC &B111 ;@NUMTOWORD 'CONVERT
EXIT &B1111

>SBN_OTHER
INC 0 'READ NEXT CHARACTER
JEI !B ,0 <SBN_BIN 'BINARY?
MOVE 16 2 'SET BASE TO HEX
JUMP <SBN_O_EXIT

>SBN_BIN
MOVE 2 2 'SET BASE TO BINARY

>SBN_O_EXIT
INC 0 'POINT TO ACTUAL START OF NUMBER
DEC (1 'LENGTH -= 2
JUMP <SBN_EXIT

'REMOVE LEADING ZEROES

'LOCATION, LENGTH
'-> LOCATION, LENGTH

:@NO0 'NO0
PR &B1111 &B11
MOVE !0 2 'SEARCH FOR NONZERO DIGIT
FUNC &B111 ;@SFAFIND 'ANTIFIND FOR 0
REC &B1100 'GET RESULT
JEI 0 3 <NO0_ZERO 'SPECIAL CASE FOR ZERO
SUBR 0 2 = % 'GET Δ
ADDR 2 0 = % 'ADD TO FINAL LOCATION
SUBR 2 1 = % 'SUB FROM FINAL LENGTH

>NO0_EXIT
SRE &B11 &B1111

>NO0_ZERO
MOVE 1 1 'SET LENGTH TO 1
JUMP <NO0_EXIT

'PRINT DECIMAL NUMBER
'NUMBER
'->

:@DEC
I 10 'PUSH BASE
;@WORDTONUM 'CONVERT TO TEXT NUMBER
;@MPRINT 'PRINT IT
]

'PRINT BINARY NUMBER
'NUMBER
'->

:@BIN
I 2 'PUSH BASE
;@WORDTONUM 'CONVERT TO TEXT NUMBER
;@MPRINT 'PRINT IT
]

'PRINT HEXADECIMAL NUMBER
'NUMBER
'->

:@HEX
I 16 'PUSH BASE
;@WORDTONUM 'CONVERT TO TEXT NUMBER
;@MPRINT 'PRINT IT
]

'PRINT NUMBER OF ARBITRARY BASE
'NUMBER, BASE
'->

:@NPRINT
;@WORDTONUM
;@MPRINT
]

'NO0 VERSIONS OF NUMPRINT ROUTINES

'PRINT DECIMAL NUMBER
'NUMBER
'->

:@NO0DEC
I 10 'PUSH BASE
;@WORDTONUM 'CONVERT TO TEXT NUMBER
;@NO0
;@MPRINT 'PRINT IT
]

'PRINT BINARY NUMBER
'NUMBER
'->

:@NO0BIN
I 2 'PUSH BASE
;@WORDTONUM 'CONVERT TO TEXT NUMBER
;@NO0
;@MPRINT 'PRINT IT
]

'PRINT HEXADECIMAL NUMBER
'NUMBER
'->

:@NO0HEX
I 16 'PUSH BASE
;@WORDTONUM 'CONVERT TO TEXT NUMBER
;@NO0
;@MPRINT 'PRINT IT
]

'PRINT NUMBER OF ARBITRARY BASE
'NUMBER, BASE
'->

:@NOPRINT
;@WORDTONUM
;@NO0
;@MPRINT
]

'COPY A NUMBER TO MEMORY
'NUMBER, BASE, LOCATION
'->

:@COPYNUM
PR &B1 &B1 'SAVE LOCATION FOR LATER
;@WORDTONUM 'GET NUMBER
FUNC &B1 ;@FCP 'PUSH LOCATION
EXIT &B1

:@NL 'PRINT A NEWLINE
I 10
;@PC
]

'KEYBOARD SUBROUTINES

'GET AND CONVERT KEYPRESS
'-> KEY PRESSED

:@@INKEY
;@KEYB 'RUN KEYBOARD
;@TOKEN 'CONVERT KEYPRESS
]

'AWAIT A KEYPRESS
'-> CHARACTER
:@GETKEY 'GTK
PSR 0
>GTK_LOOP
;@BTN
G 0 'GET BUTTONS PRESSED
JEI 128 0 <GTK_DELETE 'DELETE?
JEI 16 0 <GTK_ENTER 'ENTER?
;@@INKEY
G 0
>GTK_RES
JEI 0 0 <GTK_LOOP 'REPEAT UNTIL NONZERO

;@CLICK 'CLICK

R 0 'PASS RESULT
RSR 0
]

>GTK_DELETE
MOVE 8 0 'DELETE
JUMP <GTK_RES 'RESUME

>GTK_ENTER
MOVE 10 0 'ENTER
JUMP <GTK_RES 'RESUME

'CLICK
:@CLICK
PE &B11
MOVE 9 0
MOVE 0 1
BEEP 0 1
EXIT &B11



'KEYBOARD
'-> LETTER OR NULL
:@KEYB 'KB
PE &B100000001111111
MOVE ;KB_KEYS 14 'PUT KB ON SCREEN
MOVE 0 0 'R0=FINAL CHARACTER
'GET CURRENT TOUCH DATA
TOUCH 1 2 3
'R1=X1
'R2=Y1
'R3=T1
JEI 0 3 <KB_NULL 'NULL?

'A TOUCH HAS BEEN DETECTED, GET ITS ENDPOINT
>KB_TOUCHLOOP
TOUCH 4 5 6
'R4=X2
'R5=Y2
'R6=T2
JNI 0 6 <KB_TOUCHLOOP

SUBI 4 1 = % 'OFFSET FOR KEYS
SUBI 4 2 = % 'OFFSET FOR KEYS

'COORDINATES OF TOUCH START AND END FOUND
'WORK OUT ΔX AND ΔY
SUBR 1 4 = % 'ΔX
SUBR 2 5 = % 'ΔX

'WORK OUT IF THEY'RE OVER DELTA
SDIVR ;_Δ 4 = =
SIGN 4 =
SDIVR ;_Δ 5 = =
SIGN 5 =

'CREATE OFFSET IN R6
MULI 32 5 6 = 'GET Y
ADDR 4 6 = % 'ADD IN X

'CREATE BASE ADDRESS
FUNC &B1110 ;@TCHAR 'GET CHARACTER SPOTS
REC &B1110

SUBI 5 1 = % 'OFFSET FOR KEYBOARD AND SCREEN
SUBI 2 2 = %

DIVI 4 1 = = 'DIVIDE DOWN X
MULI 4 1 = = 'MULTIPLY UP X

DIVI 4 2 = = 'DIVIDE DOWN Y
MULI 4 2 = = 'MULTIPLY UP Y

ADDI 7 1 = % 'OFFSET FOR SCREEN LAYOUT
ADDI 4 2 = %

FUNC &B1110 ;@TADDRESS 'GET BASE ADDRESS
REC &B1110

ADDR 6 1 = % 'CREATE FINAL ADDRESS
LOADR 1 0 'GET CHARACTER

>KB_NULL
SRE &B1 &B100000001111111


'CONVERT KEYBOARD TOKENS
'RAW KEYPRESS
'-> PROCESSED KEYPRESS

:@TOKEN 'TOKEN
PR &B1 &B1
JEI ! 0 <TOKEN_8 'DELETE?
JEI ! 0 <TOKEN_10 'NEWLINE?
JEI &HE2A9 0 <TOKEN_0 'NULL?
JEI ! 0 <TOKEN_SHIFT 'UPSHIFT?
JEI ! 0 <TOKEN_SC 'SPECIAL CHARACTER?

>TOKEN_RET
SRE &B1 &B1 'RETURN VALID CHARACTER

>TOKEN_8
MOVE 8 0 'DELETE
JUMP <TOKEN_RET

>TOKEN_10
MOVE 10 0 'NEWLINE
JUMP <TOKEN_RET

>TOKEN_0
MOVE 0 0 'NULL
JUMP <TOKEN_RET

>TOKEN_SHIFT
;@KBSHIFT 'CALL SHIFT
JUMP <TOKEN_0 'RETURN NULL

>TOKEN_SC
;@KBSC 'CALL SPECIAL CHARACTER SELECTOR
G 0 'GET SELECTION
JUMP <TOKEN_RET 'RETURN

'SHIFT THE KEYBOARD
:@KBSHIFT
PE &B111
'GET LETTERS FROM THE KEYBOARD AND XOR WITH 32 TO CHANGE CASE
MOVE <KB_LETTERSTART 0 'R0=POINTER

>KBS_SLOOP
JLI+ <KB_LETTEREND )0 <KBS_EXIT 'END OF LETTERS REACHED?
JNI ! ,0 <KBS_VALIDROW
ADDI &H2C 0 = % 'GO TO NEXT ROW

>KBS_VALIDROW
ANDI &HFFDF ,0 2 'MASK OUT 32'S PLACE
'CHARACTER IS NOW UPPERCASE, TEST IF LETTER
JGI+ !A 2 <KBS_SLOOP 'LESS THAN A?
JLI+ !Z 2 <KBS_SLOOP 'MORE THAN Z?
'VALID LETTER
XORI &H20 ,0 = 'FLIP CASE

JUMP <KBS_SLOOP

>KBS_EXIT
REFR
EXIT &B111

'...KSC
:@KBSC 'SPECIAL CHARACTER SELECTOR
'RETURNS: CHARACTER SELECTED
PE &B1111111111
PSR 14
LOADM ;_KSC 8 'CHECK FLAG
JEI 0 8 <KSC_B 'RETURN NULL IF OFF
'INITIALISE
MOVE 0 0 'R0=CHARACTER SELECTED
MOVE 0 1 'R1=PAGE
MOVE 0 2 'R2=CHR
MOVE ;KB_SC 14 'SET UP SCREEN

>KSC_MAIN
BUTTON 3 'GET BUTTON
ANDI &HFEFF 3 = 'REMOVE #L
JNI 0 3 <KSC_MAIN 'WAIT FOR NO PRESS
ANDI &HFF 1 = 'REMOVE EXCESS BITS
ANDI &HFF 2 = 'REMOVE EXCESS BITS
LEFTI 8 1 0 % 'FORM CHARACTER NUMBER
ADDR 2 0 = %
<KSC_INIT
>KSC_LOOP
ADDR 14 2 3 % 'GET CHR POSITION
LOADR 3 4 'GET CHR
STOREIR ! 3 'BLINK CURSOR
REFR 'REFRESH
STORER 4 3 'PUT BACK CHR
REFR 'REFRESH
BUTTON 3 'GET BUTTON
ANDI &H100 3 4 'AND OUT #L
ANDI &HFEFF 3 5 'REMOVE #L
TOUCH 6 = = 'GET TOUCH STATUS
JEI 0 6 <KSC_TSKIP 'SKIP TOUCH CODE
;@@TOUCH 'GET TOUCH ADDRESS
'INC 11 'DISCARD T
<KSC_TOUCH 'HANDLE TOUCH INPUT
G 2
JUMP <KSC_MAIN

>KSC_TSKIP 
JEI &H100 4 <KSC_L 'L PRESSED?
'NAV HANDLERS
JEI 1 5 <KSC_UP
JEI 2 5 <KSC_DOWN
JEI 4 5 <KSC_LEFT
JEI 8 5 <KSC_RIGHT
'BUTTON HANDLERS
JEI 16 5 <KSC_END
JEI 32 5 <KSC_B
JUMP <KSC_LOOP

>KSC_UP
SUBI 16 1 = % 'PAGE UP
JUMP <KSC_MAIN

>KSC_DOWN
ADDI 16 1 = % 'PAGE DOWN
JUMP <KSC_MAIN

>KSC_LEFT
DEC 1 'PAGE LEFT
JUMP <KSC_MAIN

>KSC_RIGHT
INC 1 'PAGE RIGHT
JUMP <KSC_MAIN

>KSC_B
MOVE 0 0 'RESET TO NULL
JUMP <KSC_END 'END

>KSC_L
'NAV HANDLERS
JEI 1 5 <KSC_UP_L
JEI 2 5 <KSC_DOWN_L
JEI 4 5 <KSC_LEFT_L
JEI 8 5 <KSC_RIGHT_L
JUMP <KSC_LOOP

>KSC_UP_L
SUBI 32 2 = 9 'CHR UP
JEI 1 9 <KSC_C_UP
JUMP <KSC_MAIN

>KSC_DOWN_L
ADDI 32 2 = % 'CHR DOWN
JLI+ &HFF 2 <KSC_C_DOWN
JUMP <KSC_MAIN

>KSC_LEFT_L
SUBI 1 2 = 9 'CHR LEFT
JEI 1 9 <KSC_C_UP
JUMP <KSC_MAIN

>KSC_RIGHT_L
INC 2 'CHR RIGHT
JLI+ &HFF 2 <KSC_C_DOWN
JUMP <KSC_MAIN

>KSC_C_UP
JUMP <KSC_LEFT

>KSC_C_DOWN
JUMP <KSC_RIGHT

>KSC_TOUCH
PR &B111 &B11 'GET ADDRESS, TIME
JEI 0 1 <KSC_NT 'NO TOUCH?
SUBR 14 0 = % 'SUBTRACT SCREEN POSITION
ANDI &HFF 0 = 'GET LAST TWO HEX DIGITS
R 0 'PASS CHARACTER NUMBER
EXIT &B111

>KSC_NT 'NO TOUCH
R 2 'RETURN CHARACTER
EXIT &B111

>KSC_END
;@BTN 'WAIT FOR BUTTON RELEASE
R 0 'PASS CHARACTER
RSR 14
REFR
EXIT &B1111111111

>KSC_INIT 'FILL TOP OF SCREEN WITH CHARACTERS STARTING AT PAGE NUMBER
COPY 14 8 'R8=POINTER
LEFTI 8 1 7 % 'R7=COUNTER
>KSC_INITLOOP
STORER 7 8 'DISPLAY CHARACTER
INC 7
INC 8 'INCREMENT COUNTER AND POINTER
ANDI &HFF 7 6 'GET LAST TWO HEX DIGITS OF COUNTER
JNI 0 6 <KSC_INITLOOP 'KEEP GOING UNTIL SCREEN IS FILLED
>KSC_NUMS
R 0 'PUSH CHARACTER
I 10 'DECIMAL
I <KB_DEC 'PLACE ON SCREEN
;@COPYNUM
R 0 'PUSH CHARACTER
I 16 'HEX
I <KB_HEX 'PLACE ON SCREEN
;@COPYNUM
STOREM 0 <KB_CHR 'PLACE CHR ON SCREEN
]


'INPUT, ALLOW NEWLINES

'LOCATION, LENGTH OF INPUT BUFFER
'-> LOCATION, LENGTH OF ACTUAL INPUT

:@INPUT
I 1
;@UINPUT
]

'INPUT, FORBID NEWLINES

'LOCATION, LENGTH OF INPUT BUFFER
'-> LOCATION, LENGTH OF ACTUAL INPUT

:@INPUTL
I 0
;@UINPUT
]


'GET TEXT INPUT FROM THE USER

'LOCATION, LENGTH OF INPUT BUFFER, ENTER FLAG
'-> LOCATION, LENGTH OF ACTUAL INPUT

:@UINPUT 'IN
PR &B110000001111111 &B1000011

>IN_RESET 'RESET POINT FOR CLRBTN
'R0=LOCATION OF BUFFER
'R1=LENGTH OF BUFFER
'R6=ENTER FLAG

'FIND NULL
FUNC &B1 ;@FINDNULL
G 3 'R3=NULL LOCATION
SUBR 0 3 2 % 'R2=LENGTH UNTIL NULL
SUBR 2 1 2 % 'R2=CLEAR LENGTH
JGR+ 2 1 <IN_ESKIP 'SKIP ERASE
R 3 'CLEAR LOCATION
R 2 'CLEAR LENGTH
;@ERASE 'ERASE REMAINING BUFFER

>IN_ESKIP
;@13
;@14
SUBR 2 1 2 % 'R2=CHARACTERS TYPED
SUBR 0 3 = % 'R3=CURSOR LOCATION
'CHECK FOR FULL BUFFERS
JGR+ 3 1 <IN_FB
JUMP <IN_INIT

>IN_FB
COPY 1 3 'RESET CURSOR LOCATION TO LENGTH
COPY 1 2 'RESET CHRS TYPED TO LENGTH

>IN_INIT 'INITIALISE THE UPPER SCREEN
FUNC &B1001 ;@MPRINT 'PRINT UP TO CURSOR

>IN_RESUME 'START PRINTING CURSOR+PAST CURSOR
SUBR 2 1 .11 % 'PUT REMAINING CHRS ON STACK
<IN_CURP 'CURSOR PRINT

'MASS PRINT AFTER THE CURSOR
'LOCATION=R0+R3, LENGTH=R2-R3
ADDR 0 3 4 % 'R0+R3
SUBR 3 2 5 % 'R2-R3
FUNC &B110000 ;@MPRINT
SUBR 2 1 4 % 'GET REMAINING CHARACTERS

>IN_DP 'DELETE REENTRY POINT
;@CLICK 'CLICK
REFR

>IN_LOOP
;@BTN
G 4 'GET BUTTON PRESS

JEI #A 4 <IN_EXIT 'A=OK
JEI #B 4 <IN_ENTERBTN 'B=NEWLINE
JEI #Y 4 <IN_DELETE 'Y=DELETE
JEI 832 4 <IN_CLRBTN 'L+R+X=DELETE ALL
JEI #LEFT 4 <IN_LEFTBTN 'LEFT=DEC CURSOR
JEI #RIGHT 4 <IN_RIGHTBTN 'RIGHT=INC CURSOR
JEI #UP 4 <IN_HOME 'UP=HOME
JEI #DOWN 4 <IN_END 'DOWN=END
;@@INKEY 'GET KEY
G 4 'RECEIVE KEYPRESS

>IN_VALIDATE
JEI 0 4 <IN_LOOP 'NULL?
JEI 8 4 <IN_DELETE 'DELETE?
JER 1 2 <IN_LOOP 'FULL BUFFER?
JNI 0 6 <IN_APPEND 'ENTER FLAG SET?
'ENTER IS NOT ALLOWED
JEI 10 4 <IN_LOOP

>IN_APPEND 'APPEND A CHARACTER
<IN_BUSYDIAMOND 'SHOW DIAMOND
<IN_CLEAR
R 4 'PRINT APPENDED CHARACTER
;@PC
'COPY BLOCK OF CHARACTERS IN BUFFER AFTER CURSOR 1 SPOT FORWARDS
'BLOCK LOCATION:R0+R3
ADDR 3 0 .11 %
'BLOCK LENGTH=R2-R3
SUBR 3 2 .11 %
'BLOCK DESTINATION:R0+R3+1
ADDI 1 ?1 .11 %
'MEMORY NEEDS TO BE COPIED BACKWARDS
;@BCP
ADDR 3 0 5 % 'APPEND CHARACTER AT [R0+R3]
STORER 4 5 'APPEND TO BUFFER
INC 2 'ADVANCE LENGTH COUNT
INC 3 'ADVANCE CURSOR
JUMP <IN_RESUME

>IN_EXIT
<IN_SCCLR 'SCREEN CLEAR
SRE &B101 &B110000001111111

>IN_ENTERBTN
MOVE 10 4 'PASS 10 TO APPEND ROUTINE
JUMP <IN_VALIDATE 'APPEND

>IN_DELETE
<IN_BUSYDIAMOND 'SHOW DIAMOND
JEI 0 3 <IN_DP 'EXIT IF AT START OF BUFFER
<IN_CLEAR
I 8 'PRINT APPENDED CHARACTER
;@PC
'COPY BLOCK OF CHARACTERS IN BUFFER AFTER CURSOR 1 SPOT FORWARDS
'BLOCK LOCATION:R0+R3
ADDR 3 0 .11 %
'BLOCK LENGTH=R2-R3
SUBR 3 2 .11 %
'BLOCK DESTINATION:R0+R3-1
SUBI 1 ?1 .11 %
'MEMORY NEEDS TO BE COPIED FOREWARDS
;@FCP
'WRITE A NULL AFTER COPY
'NULL LOCATION=R2+R0-1
ADDR 2 0 4 % 'GET NULL LOCATION
STOREIR 0 {4 'STORE IT THERE
DEC 2 'RETREAT LENGTH COUNT
DEC 3 'RETREAT CURSOR
JUMP <IN_RESUME


>IN_CLRBTN
<IN_BUSYDIAMOND 'SHOW DIAMOND
<IN_SCCLR
STOREIR 0 0 'ERASE FIRST CHARACTER OF BUFFER
JUMP <IN_RESET 'RESET

>IN_HOME
<IN_BUSYDIAMOND 'SHOW DIAMOND
MOVE 0 3 'RESET CURSOR
JUMP <IN_REFR 'REDRAW

>IN_END
<IN_BUSYDIAMOND 'SHOW DIAMOND
COPY 2 3 'SET CURSOR TO END

>IN_FULLRD 'FULL REDRAW
<IN_SCCLR 'ERASE SCREEN
JUMP <IN_INIT 'REDRAW

>IN_LEFTBTN
<IN_BUSYDIAMOND 'SHOW DIAMOND
DEC 3 'DECREMENT CURSOR
JEI &HFFFF 3 <IN_HOME 'UNDERFLOW?
JUMP <IN_REFR

>IN_RIGHTBTN
<IN_BUSYDIAMOND 'SHOW DIAMOND
INC 3 'INCREMENT CURSOR
JGR+ 3 2 <IN_END 'IF BEYOND BUFFER, JUMP TO END
JUMP <IN_FULLRD 'FULL REDRAW



>IN_CURP
PR &B1 &B1
'CHECK IF BUFFER FULL
JEI 0 0 <IN_XCUR 'X CURSOR
'CHECK IF FEWER THAN 100 CHARACTERS REMAIN
JGI+ 100 0 <IN_NUMCUR 'GENERATE NUMBER CURSOR

I &HE17A 'DEFAULT CURSOR

>IN_CURPEXIT
;@PC
EXIT &B1

>IN_NUMCUR
ADDI &HE100 0 .11 % 'GENERATE CURSOR CHR
JUMP <IN_CURPEXIT

>IN_XCUR
I ! 'OUT OF SPACE CURSOR
JUMP <IN_CURPEXIT

>IN_CLEAR
'DELETE UP TO CURSOR
'DELETE COUNT=(R2-R3)+7
SUBR 3 2 5 %
ADDI 1 5 = % 'ADDI 7 5 = %
I 8 'DELETE
R 5 'R5 TIMES
;@CHRREP
]

>IN_SCCLR 'SCREEN CLEAR
<IN_CLEAR 'CLEAR UP TO CURSOR
'CALCULATE ADDITIONAL CLEARING
'CLEAR (R3) CHARACTERS
I 8 'DELETE
R 3 'R3 TIMES
;@CHRREP
]

>IN_REFR
<IN_CLEAR 'CLEAR UP TO CURSOR
JUMP <IN_RESUME 'REDRAW

>IN_BUSYDIAMOND
PE &B1
MOVE ! 0
ILOADR 31 13 .11 'GET CORNER CHR
ISTORER 0 13 31 'PUT DIAMOND ON SCREEN
REFR
ISTORER .11 13 31 'RESTORE SCREEN
EXIT &B1


'REPEAT A CHARACTER
'CHARACTER, REPETITION COUNT
'->

:@CHRREP 'CRP
PR &B11 &B11

>CRP_LOOP
JEI 0 (1 <CRP_EXIT
FUNC &B1 ;@PC 'PRINT
JUMP <CRP_LOOP

>CRP_EXIT
EXIT &B11

'CURSOR PRINT CHARACTER
'PARAMETER: CHR
'PRINTS USING A CURSOR

:@CURPC
I 8 'DELETE
;@PC
;@PC 'PRINT CHARACTER
R ;_CRPC 'GET CURSOR
;@PC 'PRINT IT
]

'CLEAR TERMINAL

:@CLS
STOREIM 0 ;_CUR
R ;_LOC 'GET LOCATION
R ;_LEN 'GET LENGTH
;@ERASE 'CLEAR THE SCREEN
]

'LOAD FILE
'LOCATION OF NAME, LOCATION TO LOAD INTO
'-> LOCATION OF FILE END, SUCCESS FLAG

:@LOADFILE
SWAP .11 =
COMPILE .11 = = =
]

'LOAD TEXT
'LOCATION OF NAME, LOCATION TO LOAD INTO
'-> LOCATION OF FILE END, SUCCESS FLAG

:@LOADTEXT
SWAP .11 =
LOAD .11 = = =
]

'SAVE FILE
'NAME, LOCATION, LENGTH
'-> SUCCESS?

:@SAVEFILE
PR &B1111 &B111 'R0=NAME, R1=LOCATION, R2=LENGTH
DATASAVE 1 2 0 3 'PERFORM THE SAVE
SRE &B1000 &B1111 'SEND SUCCESS FLAG

'SAVE TEXT
'NAME, LOCATION, LENGTH
'-> SUCCESS?

:@SAVETEXT
PR &B1111 &B111 'R0=NAME, R1=LOCATION, R2=LENGTH
SAVE 1 2 0 3 'PERFORM THE SAVE
SRE &B1000 &B1111 'SEND SUCCESS FLAG

'SAVE FILE WITH NAME INPUT
'LOCATION, LENGTH OF BLOCK TO SAVE
'-> SUCCESS FLAG

:@SAVEFILENAME
I 1 'PASS FILE FLAG
;@INPUT_SAVE
]

'SAVE TEXT WITH NAME INPUT
'LOCATION, LENGTH OF BLOCK TO SAVE
'-> SUCCESS FLAG

:@SAVETEXTNAME
I 0 'PASS FILE FLAG
;@INPUT_SAVE
]

'SAVE WITH NAME INPUT
'LOCATION, LENGTH OF BLOCK TO SAVE,FILE FLAG
'-> SUCCESS FLAG

:@INPUT_SAVE 'IN_S
PR &B1111 &B111
'R0=LOCATION
'R1=LENGTH
'R2=FILE FLAG (SET FOR FILE, RESET FOR TEXT)

'GET NAME FROM THE USER
I ;FILE 'USING FILE BUFFER
I 14 'MAX NAME LENGTH
;@INPUTL 'GET SINGLE LINE
INC 11 'DISCARD LENGTH
S &B11 'SEND LOCATION AND LENGTH
JEI 0 2 <IN_S_TEXT
'FILE
;@SAVEFILE
JUMP <IN_S_END

>IN_S_TEXT
;@SAVETEXT

>IN_S_END
EXIT &B1111

'LOAD FILE WITH NAME INPUT
'LOCATION
'-> FILE END, SUCCESS FLAG

:@LOADFILENAME
I 1 'PASS FILE FLAG
;@INPUT_LOAD
]

'LOAD TEXT WITH NAME INPUT
'LOCATION
'-> FILE END, SUCCESS FLAG

:@LOADTEXTNAME
I 0 'PASS FILE FLAG
;@INPUT_LOAD
]

'LOAD WITH NAME INPUT
'LOCATION, FILE FLAG
'-> FILE END, SUCCESS FLAG

:@INPUT_LOAD 'IN_L
PR &B1111 &B101
'R0=LOCATION
'R2=FILE FLAG (SET FOR FILE, RESET FOR TEXT)

'GET NAME FROM THE USER
I ;FILE 'USING FILE BUFFER
I 14 'MAX NAME LENGTH
;@INPUTL 'GET SINGLE LINE
INC 11 'DISCARD LENGTH
S &B1 'SEND LOCATION AND LENGTH
JEI 0 2 <IN_L_TEXT
'FILE
;@LOADFILE
JUMP <IN_L_END

>IN_L_TEXT
;@LOADTEXT

>IN_L_END
EXIT &B1111

'INPUT NUMBER WITH BASE
'PARAMETER: BASE
'RETURNS NUMBER

:@INPUTNUM
PR &B1 &B1 'R0=BASE

'STORE BASE TEMPORARILY
I ;WTN_LOC 'PASS LOCATION
FUNC &B1 ;@LENCALC 'PASS LENGTH

;@INPUT 'GET NUMBER
R 0 'PASS BASE
;@NUMTOWORD 'CONVERT NUMBER

EXIT &B1

'CLEAR NUMBER BUFFER
'->
:@NEWNUM
STOREIM 0 ;WTN_LOC 'ERASE NUMBER BUFFER
]

'CLEAR FILE BUFFER
'->
:@NEWFILE
STOREIM 0 ;FILE 'ERASE FILE BUFFER
]

'PIXEL ENGINE
'DRAWS PIXELS LIKE THIS: 
'(0,0) IS TOP LEFT AND (63,47) IS BOTTOM RIGHT
'MAIN SUBROUTINES:
'@@PXON
'@@PXOFF
'@@PXFLIP
'@@PXTEST

'TURN ON A PIXEL
'X,Y
'->

:@@PXON
;@PXFIND
PR &B11 &B11
'R0=ADDRESS
'R1=MASK
ORR 1 ,0 = 'OR MASK INTO ADDRESS
<DOT 'CREATE PIXEL
EXIT &B11

'TURN OFF A PIXEL
'X,Y
'->

:@@PXOFF
;@PXFIND
PR &B11 &B11
'R0=ADDRESS
'R1=MASK
ANDR |1 ,0 = 'AND IN PIXELS
<DOT 'CREATE PIXEL
EXIT &B11

'FLIP A PIXEL
'X,Y
'->

:@@PXFLIP
;@PXFIND
PR &B11 &B11
'R0=ADDRESS
'R1=MASK
XORR 1 ,0 = 'XOR MASK INTO ADDRESS
<DOT 'CREATE PIXEL
EXIT &B11

'TEST A PIXEL
'X,Y
'-> RESULT

:@@PXTEST
;@PXFIND
PR &B11 &B11
'R0=ADDRESS
'R1=MASK
ANDR 1 ,0 .11 'GET PIXEL
TRUE .11 = 'CONVERT TO BOOLEAN
EXIT &B11

'TEST, THEN FLIP A PIXEL
'ARGUMENTS: X,Y
'RETURNS: 0 FOR OFF, NONZERO FOR ON
:@PXTF
PR &B11 &B11
FUNC &B11 ;@@PXTEST
FUNC &B11 ;@@PXFLIP
EXIT &B11




'FIND A PIXEL (COORDINATES AND PIXEL MASK)
'X, Y
'-> ADDRESS, MASK

:@PXFIND
PR &B1111 &B11

'GET ADDRESS
DIVI 2 0 2 0 'X/2
DIVI 2 1 3 1 'Y/2
MULI 32 1 = = 'Y*32
ORR 1 0 = 'R0=ADDRESS
ADDR ;_PIXEL_OFFSET 0 .11 % 'CREATE ADDRESS

'GET PIXEL NUM
LEFTI 1 3 = % '<<Y RMD
ADDR 3 2 = % 'R2=PIXEL NUMBER

'GET PIXEL MASK
DECODE 2 .11
EXIT &B1111

'EXPECTS ADDRESS OF CHR IN R0
'FIX NULL PIXEL BLOCKS
>DOT
ORI ! ,0 = 'OFFSET TO GENERATE PIXELS
JNI ! ,0 <DOT_EXIT
STOREIR 0 0

>DOT_EXIT
]




:@PXWRAP 'PIXEL WRAPPER
'X,Y
'-> X,Y FOR PIXEL ENGINE
ANDI &H3F ?1 = 'LIMIT X
DIVI &H30 ?0 = % 'LIMIT Y
]

:@TOUCHPIX 'GET TOUCHED PIXEL
'RETURNS: X, Y, T WITH X AND Y IN TOUCH UNITS
PE &B111
TOUCH 0 1 2 'GET TOUCH
DIVI 4 0 = = 'DIVIDE DOWN X
DIVI 4 1 = = 'DIVIDE DOWN Y
SUBI 8 0 = % 'OFFSET X
SUBI 6 1 = % 'OFFSET Y
'SEND &B11 'SEND X AND Y
SRE &B111 &B111 'SEND X, Y AND T
'EXIT &B111 'RETURN

'...PXC
:@PXCLIP 'PIXEL CLIPPER
'ARGUMENTS: X,Y
'RETURNS X,Y IF VALID, OTHERWISE 0,48
PR &B11 &B11 'R0=X, R1=Y

JGI+ 64 0 <PXC_XSKIP 'IS X VALID?
JUMP <PXC_INVALID

>PXC_XSKIP
JGI+ 48 1 <PXC_YSKIP 'IS Y VALID?

>PXC_INVALID 'Y ISN'T VALID, RESET X,Y
MOVE 0 0
MOVE 48 1

>PXC_YSKIP 'RETURN
SRE &B11 &B11

'TURN A PIXEL ON IF M!=0
'ARGUMENTS: X,Y,M
:@PXMODE '...PXM
'PSR 0
'G 0
PR &B1 &B1 'R0=MODE
JEI 0 0 <PXM_OFF 'OFF?
;@@PXON 'ON
EXIT &B1

>PXM_OFF
;@@PXOFF
EXIT &B1

'ADD ITEM TO QUEUE FORWARDS
'ITEM
'->

:@FEQ
STORER .11 ;_EQCUR 'PLACE ITEM IN QUEUE
INC ;_EQCUR 'EQC++
JER ;_QEND ;_EQCUR <FEQ_RESET_ 'END OF QUEUE?
]

>FEQ_RESET_
STOREM ;_QLOC ;_EQCUR 'EQCUR=[QLOC], RESET
]

'TAKE ITEM FROM QUEUE FORWARDS
'-> ITEM

:@FDQ
LOADR ;_DQCUR .11 'GET ITEM IN QUEUE
INC ;_DQCUR 'DQC++
JER ;_QEND ;_DQCUR <FDQ_RESET_ 'END OF QUEUE?
]

>FDQ_RESET_
STOREM ;_QLOC ;_DQCUR 'EQCUR=[QLOC], RESET
]


'ADD ITEM TO QUEUE BACKWARDS
'ITEM
'->

:@BEQ
STORER .11 ;_DQCUR 'PLACE ITEM IN QUEUE
DEC ;_DQCUR 'DQC--
JGR+ ;_QLOC ;_DQCUR <BEQ_RESET_ 'END OF QUEUE?
]

>BEQ_RESET_
STOREM ;_QEND ;_DQCUR 'DQCUR=[QEND], RESET
]

'TAKE ITEM FROM QUEUE FORWARDS
'-> ITEM

:@BDQ
LOADR ;_EQCUR .11 'GET ITEM IN QUEUE
DEC ;_EQCUR 'EQC--
JGR+ ;_QLOC ;_EQCUR <BDQ_RESET_ 'END OF QUEUE?
]

>BDQ_RESET_
STOREM ;_QEND ;_EQCUR 'EQCUR=[QLOC], RESET
]

'...CQ
:@CLRQUEUE 'RESET THE QUEUE
STOREM ;_QLOC ;_DQCUR 'RESET DQC
STOREM ;_QLOC ;_EQCUR 'RESET EQC
]

'PRINT NUMBER WITH BASE VARIABLE
'PARAMETER: NUMBER

:@BASEMODE 'OUTPUT NUMBER WITH SELECTED BASE
R ;_BASE 'GET BASE
;@NPRINT 'PRINT
]

'CHECK EQUALITY OF TWO STRINGS
'LOCATION 1, LOCATION 2, LENGTH 2
'-> NUMBER OF EQUAL CHARACTERS AT START

:@STRCHECK '...SC
';@LL_SE 'CONVERT TO LOC-LOC
PR &B1111 &B111 'R0=LOC1 'R1=LOC2 'R2=LEN
MOVE 0 3 'R3=MATCHED LENGTH COUNTER

>SC_LOOP
JNR .0 .1 <SC_EXIT 'EXIT IF UNEQUAL
JER 2 )3 <SC_EXITM 'EXIT IF FULLY MATCHED
JUMP <SC_LOOP

>SC_EXITM
DEC 3 'CORRECT OB1E

>SC_EXIT
SRE &B1000 &B1111

'BINARY STRING CHECKER
'LOCATION 1, LOCATION 2, LENGTH 2
'-> SUCCESS FLAG

:@BSC '...BSC
PR &B111 &B111 'CREATE COPY OF ARGUMENTS
FUNC &B111 ;@STRCHECK
SUBR 2 .11 % 0 'GET SUCCESS FLAG
XORI 1 0 .11 'RETURN SUCCESS
EXIT &B111


'DRAW SPRITE
:@DRAW
I 1
;@SPRITE
]

'ERASE SPRITE
:@CLEAR
I 0
;@SPRITE
]

'DRAW OR ERASE SPRITE WITH ORIGIN USING METADATA
'SPRITE WIDTH AND HEIGHT ARE STORED AT LOCATION IN THAT ORDER WITH SPRITE IMMEDIATELY AFTER
'LOCATION IS RELATIVE TO ORIGIN
'LOCATION, ADDRESS, DRAW/ERASE FLAG
'->

'0=ERASE >0=DRAW
:@SPRITE '...SPR
PR &B1111111 &B111
'R0=LOCATION
'R1=SPRITE
'R2=FLAG

'COPY 1 3 'MAKE A COPY
'ADDI 1 3 4 % 'ADD 1
'ADDI 2 3 5 % 'ADD 2
'LOADR 3 = 'GET WIDTH
'LOADR 4 = 'GET HEIGHT

LOADR 1 3 'GET WIDTH
ILOADR 1 1 4 'GET HEIGHT
ADDI 2 1 5 % 'GET ADDRESS

LOADM ;_ORIGIN 6 'GET ORIGIN
ADDR 6 0 = % 'OFFSET LOCATION
ADDR ;_SPLIMIT 6 = % 'GET LIMIT

'LOADR 5 5 'GET ADDRESS
R 0 'LOCATION
JEI 0 2 <SPR_ERASE1 'SKIP ADDRESS FOR ERASE
R 5 'ADDRESS

>SPR_ERASE1
R 6 'LIMIT
R 3 'WIDTH
R 4 'HEIGHT
JEI 0 2 <SPR_ERASE2 'ERASE?
;@SPDRAW 'DRAW SPRITE
JUMP <SPR_EXIT 'SKIP OVER ERASE CODE

>SPR_ERASE2
;@SPERASE 'ERASE SPRITE

>SPR_EXIT 'RETURN
EXIT &B1111111




'SPRITE DRAW ROUTINE
'LOCATION OF SPRITE, ADDRESS OF SPRITE, SCREEN LIMIT, WIDTH, HEIGHT
'->

:@SPDRAW '...SP
PR &B11111 &B11111
'R0=LOCATION
'R1=ADDRESS
'R2=SCREEN LIMIT
'R3=WIDTH
'R4=HEIGHT

>SP_LOOP
JLR+ 2 0 <SP_EXIT 'BEYOND SCREEN LIMIT?
JEI 0 (4 <SP_EXIT 'END OF SPRITE?
R 1 'PUSH ADDRESS
R 3 'PUSH WIDTH
R 0 'PUSH LOCATION
;@FCP 'DRAW SPRITE LINE
'DEC 4 'HEIGHT--
ADDR 3 1 = % 'ADD WIDTH TO ADDRESS
ADDI 32 0 = % 'ADVANCE TO NEXT LINE OF SCREEN
JUMP <SP_LOOP

>SP_EXIT
EXIT &B11111

'SPRITE ERASE ROUTINE
'LOCATION OF SPRITE, SCREEN LIMIT, WIDTH, HEIGHT
'->

:@SPERASE '...SE
PR &B1111 &B1111
'R0=LOCATION
'R1=SCREEN LIMIT
'R2=WIDTH
'R3=HEIGHT

>SE_LOOP
JLR+ 1 0 <SE_EXIT 'BEYOND SCREEN LIMIT?
JEI 0 3 <SE_EXIT 'END OF SPRITE?
R 0 'PUSH LOCATION
R 2 'PUSH WIDTH
;@ERASE 'ERASE SPRITE LINE
DEC 3 'HEIGHT--
ADDR 3 1 = % 'ADD WIDTH TO ADDRESS
ADDI 32 0 = % 'ADVANCE TO NEXT LINE OF SCREEN
JUMP <SE_LOOP

>SE_EXIT
EXIT &B1111


'SWAPS ONE CHARACTER FOR ANOTHER
'CHARACTER, SOURCE TABLE, DESTINATION TABLE
'-> NEW CHARACTER IF FOUND, CHARACTER IF NOT FOUND

'SWAP TABLES MUST BE NEXT TO ONE ANOTHER AND OF EQUAL LENGTH. THIS SIMPLIFIES CALLS BY NOT REQUIRING A LENGTH PARAMETER

:@SWAPTABLE 'ST
PR &B11111 &B111
'SEARCH FOR CHR IN SOURCE TABLE
R 1 'LOCATION
SUBR 1 2 .11 % 'GET ITERATIONS
R 0 'SEARCH BYTE
;@SFFIND 'FIND CHARACTER
REC &B11000 'GET ADDR+SUCCESS FLAG
JEI 0 4 <ST_FAIL 'FAIL?
SUBR 1 3 = % 'GET INDEX
RLOADR 3 2 .11 'RETURN READ FROM DESTINATION TABLE

>ST_END
EXIT &B11111 'RETURN LETTER

>ST_FAIL
SRE &B1 &B11111 'RETURN CHR

'CONVERT BUTTON INDEX TO SYMBOL
'NUMBER
'->SYMBOL

:@NUM_BTN 'BNM
I <BNM_NUM1
I <BNM_BTN
;@SWAPTABLE
]

'CONVERT BUTTON SYMBOL TO INDEX
'SYMBOL
'->NUMBER

:@BTN_NUM 'BNM
I <BNM_BTN
I <BNM_NUM2
;@SWAPTABLE
]













'MINI SUBROUTINES
:@COPY COPY ,11 .11 ]
:@SWAP SWAP .11 = ]
:@+ ADDR .11 = = = ]
:@- SUBR .11 = = = ]
:@* MULR .11 = = = ]
:@/% DIVR .11 = = = ]
:@RND RND .11 ]
:@% DIVR .11 = = % ]
:@/ DIVR .11 = % .11 ]
:@>> RIGHTR .11 = = = ]
:@<< LEFTR .11 = = = ]
:@>>1 RIGHTI 1 .11 = = ]
:@<<1 LEFTI 1 .11 = = ]

:@AND ANDR .11 = = ]
:@OR ORR .11 = = ]
:@XOR XORR .11 = = ]
:@NOT NOT .11 = ]
:@TWO TWO .11 = ]
:@TRUE TRUE .11 = ]
:@SIGN SIGN .11 = ]

:@WRITE ;@SWAP ;@STORE ]
:@STORE STORER .11 = ]
:@LOAD LOADR .11 = ]

:@X INC 11 ]
:@X+ ADDR .11 11 = % ]

'NUMBER LIBRARY

'AVC1 INTEGER LIBRARY ...I ...I@
'INTEGER FORMAT:

'64-BITS, LITTLE-ENDIAN, 2'S COMPLEMENT

'LEAST SIGNIFICANT WORD TO TOP OF STACK
'MOST SIGNIFICANT 4W-INT OF MULTINUM RESULTS TO TOP OF STACK, LIKE CARRY, BORROW, MUL MSN

'DROP A 4W-INT
'PARAMETER: 4W-INT

:I@DROP
ADDI 4 11 = % 'INCREMENT SP
]

'SWAP TOP 2 4W-INTS
'PARAMETERS: 2 4W-INTS
'RETURNS: 2 4W-INTS

:I@SWAP
PR &B11111111 &B11111111
S &B11110000 'SEND TOP NUMBER
SRE &B00001111 &B11111111 'SEND BOTTOM NUMBER

'DUPLICATE 4W-INT
'PARAMETER: 4W-INT
'RETURNS: 2 4W-INT

:I@DUP
PR &B1111 &B1111
S &B1111 'SEND COPY
SRE &B1111 &B1111

'PUSH 2ND FROM TOP TO STACK
'PARAMETERS: 2 4W-INTS
'RETURNS: 3 4W-INTS

:I@OVER
PR &B11111111 &B11111111
S &B00001111 'SEND BOTTOM NUMBER
S &B11110000 'SEND TOP NUMBER
SRE &B00001111 &B11111111 'SEND BOTTOM NUMBER

'REDUCE TO ONE WORD
'PARAMETER: 4W-INT
'RETURNS: INT

:I@REDUCE
PR &B1111 &B1111 'GET WORD
SRE &B1000 &B1111 'RETURN BOTTOM WORD


'EXPAND TO 4W-INT, UNSIGNED
'PARAMETER: INT
'RETURNS: 4W-INT

:I@EXPAND+
PR &B1 &B1 'R0=INT

>IEX_POSITIVE
I 0
I 0
I 0
SRE &B1 &B1


'EXPAND TO 4W-INT, SIGNED
'PARAMETER: INT
'RETURNS: 4W-INT

:I@EXPAND- '...IEX
PR &B1 &B1 'GET WORD
JGI- 0 0 <IEX_NEGATIVE 'NEGATIVE?
JUMP <IEX_POSITIVE 'POSITIVE CASE

>IEX_NEGATIVE
I &HFFFF
I &HFFFF
I &HFFFF
SRE &B1 &B1


'PUSH LITERAL NUMBER
'NEEDS TO CHANGE RETURN ADDRESS
'RETURNS:4W-INT

:I@LIT#
COPY ,12 .11 'GET RETURN ADDRESS
ADDI 4 .12 = % 'MODIFY RETURN ADDRESS
PR &B11111 &B1
'R0=NUMBER POINTER
LOADR 0 1 'GET ALL 4 WORDS
ILOADR 1 0 2
ILOADR 2 0 3
ILOADR 3 0 4
SRE &B11110 &B11111 'SEND 4W-INT

'PUSH LITERAL WORD NUMBER SIGNED
'NEEDS TO CHANGE RETURN ADDRESS
'RETURNS:4W-INT

:I@LIT-
LOADR ,12 .11 'GET ALL WORDS
;I@EXPAND- 'EXTEND, SIGNED
INC ,12 'MODIFY RETURN ADDRESS
] 'SEND 4W-INT

'PUSH LITERAL WORD NUMBER UNSIGNED
'NEEDS TO CHANGE RETURN ADDRESS
'RETURNS:4W-INT

:I@LIT+
LOADR ,12 .11 'GET ALL WORDS
;I@EXPAND+ 'EXTEND, UNSIGNED
INC ,12 'MODIFY RETURN ADDRESS
] 'SEND 4W-INT

'PUSH LITERAL STRING WITH BASE

'STRING FORMAT: MAY START WITH - FOR NEGATIVE
'CONTINUES WITH NUMBER DIGITS
'ENDS WITH /

'EXAMPLE:

'-6A7G/

'PARAMETER: BASE
'RETURNS: 4W-INT

:I@LIT$
COPY ,12 .11 'GET RETURN ADDRESS
PR &B11111 &B11111 'GET BASE AND RADDR
'R0-3: BASE
'R4:RADDR
R 4 'PUSH RADDR
;I@EXPAND+ 'EXPAND IT

FUNC &B1111 ;I@LOAD$ 'SEND BASE, LOAD!

R 4 'PUSH LOCATION
I -1 'LENGTH
I !/ 'LOOK FOR END OF NUMBER
;@SFFIND ;@X 'GET LOCATION
G 4 'GET RADDR
INC 4 'INCREMENT FOR TRUE RETURN ADDRESS
ISTORER 4 12 5 'MODIFY RADDR
EXIT &B11111


'LOAD STRING WITH BASE
'PARAMETERS: NUMBER LOCATION, BASE

:I@LOAD$ '...IL$
PR &B11111111 &B11111111

'R3:LOCATION
'R7:BASE
SWAP 3 0 'R0=LOC
SWAP 7 1 'R1=BASE
'R2=NEGATIVE FLAG

LOADR 0 2 'GET FIRST CHR
MOVE 0 3 'R3=SIGN FLAG
JNI !- 2 <IL$_POS 'POSITIVE?
MOVE 1 3 'R3 IS 1 FOR NEGATIVE, ADVANCE TO FIRST TRUE DIGIT
INC 0

>IL$_POS
'UNTIL A / IS REACHED, MULTIPLY BY BASE AND ADD DIGIT
;I@LIT+ 0 'PUT SCRATCHNUM ON STACK

>IL$_LOOP
LOADR 0 2 'GET CHR
JEI !/ 2 <IL$_EXIT 'END OF NUMBER?

R 1 'SEND BASE
;I@EXPAND+
;I@MUL 'MULTIPLY SCRATCHNUM BY BASE
;I@DROP 'DROP MSW

R 2 'SEND NUM
;@D_I 'CONVERT TO INT
;I@EXPAND+ 'CONVERT TO 4W-INT
;I@ADD 'ADD IN DIGIT
;I@DROP 'DROP CARRY

INC 0 'INC POINTER
JUMP <IL$_LOOP

>IL$_EXIT
JNI 1 3 <IL$_FINALISE 'POSITIVE?
;I@TWO 'INVERT NUMBER

>IL$_FINALISE
EXIT &B11111111




'GENERATE DIGITS OF A NUMBER, UNSIGNED

'PARAMETERS: 4W-INT NUMBER, BASE
'RETURNS: LOCATION, LENGTH OF NUMBER

'FOR PRINTING

'DEC LENGTH:UNTERMINATED POSITIVE
'DEC LOCATION:UNTERMINATED NEGATIVE

:I@GD '...GD
;I@REDUCE 'REDUCE THE BASE
PR _0123456789 _01234

MOVE ;IGD_LOC 9 'R9=DIGIT CURSOR
MOVE !0 ;IGD_LOC 'PRE-PREPARE THE IGDLOC

'R0-3=NUMBER
FUNC _0123 ;I@TRUE
JEI 0 ,11 <GD_ZERO
;I@DROP
'R4=BASE
MOVE 0 5 'R5-8=POWER OF BASE
MOVE 0 6
MOVE 0 7
MOVE 1 8

'CREATE THE POWER TABLE!
;I@LIT+ 0 'SENTINEL 0 FOR LATER STEP

>GD_POWERLOOP
S _01235678 'SEND NUMBER AND POWER
;I@< 'NUMBER < POWER?
JEI 1 ,11 <GD_PWEXIT 'END?

;I@DROP
S _5678 '"KEEP" OLD POWER
FUNC _4 ;I@EXPAND+ 'SEND BASE
FUNC _5678 ;I@MUL 'MULTIPLY POWER
;I@TRUE 'GET CARRY
JEI 1 ,11 <GD_M_EXIT
;I@DROP
REC _5678 'RECEIVE POWER BACK, CHANGING IT
JUMP <GD_POWERLOOP

>GD_M_EXIT
;I@DROP 'DROP OVERFLOW

>GD_PWEXIT
;I@DROP 'DROP CARRY OR MUL LAST VALUE

'THERE'S NOW A TOWER OF POWERS ON S11
'REPEATEDLY SUBTRACT THESE FROM THE NUMBER TO GENERATE DIGITS

>GD_SUBLOOP
;I@DUP 'DUPLICATE CURRENT POWER
;I@TRUE 'IS IT ZERO YET?
JEI 0 ,11 <GD_DONE 'DETECT SENTINEL 0

;I@DROP 'DROP TEST VALUE
REC _5678 'GET POWER TO USE
MOVE 0 4 'RESET R4

>GD_DIGLOOP 'GENERATE DIGIT IN R4
FUNC _01235678 ;I@SUB 'SUB NUMBER FROM POWER
JEI 1 ,11 <GD_NEXTDIGIT 'MOVE TO NEXT DIGIT?
;I@DROP 'DROP CARRY
REC _0123 'GET NUMBER BACK
INC 4 'INC DIGIT
JUMP <GD_DIGLOOP 'KEEP SUBTRACTING

>GD_NEXTDIGIT
;I@DROP
;I@DROP 'DISPOSE OF SUB RESULT ENTIRELY
FUNC _4 ;@I_D 'CONVERT TO DIGIT
STORER .11 )9 'STORE DIGIT
'REFR
JUMP <GD_SUBLOOP

>GD_ZERO
;I@DROP 'DROP TRUE
INC 9
JUMP <GD_ZERO2

>GD_DONE
;I@DROP 'DISPOSE OF TRUE AND SENTINEL
;I@DROP

>GD_ZERO2
STOREIR !/ )9 'TERMINATE THE NUMBER
STOREIR 0 )9 'TERMINATE THE NUMBER
I ;IGD_LOC 'PUSH DESTINATION
;@BLOCK 'RETURN LOC, LEN
EXIT _0123456789




'STORE STRING WITH BASE
'PARAMETERS: 4W-INT NUMBER, BASE, ADDRESS
:I@STORE$
PR &B1111 &B1111 'GET ADDRESS FIRST
;I@GD 'CONVERT NUMBER
R 3
;@FCP 'COPY IT TO ADDRESS
EXIT &B1111


'LOAD NUMBER LITERAL
'RETURNS: 4W NUMBER THERE

:I@LOAD+
COPY ,12 .11 'GET RETURN ADDRESS
ADDI 1 .12 = % 'MODIFY RETURN ADDRESS
PR &B11111 &B10000 'GET ARGUMENT
LOADR 4 = 'READ ARGUMENT
ILOADR 3 4 3
ILOADR 2 4 2
ILOADR 1 4 1
LOADR 4 0
SRE &B1111 &B11111


'LOAD NUMBER
'PARAMETER: ADDRESS (IN 4W FORMAT, TOP 3W ARE ALWAYS IGNORED!)
'RETURNS: 4W NUMBER THERE

:I@LOAD#
PR &B11111111 &B1111 'GET ADDRESS
'R3=ADDRESS
ILOADR 3 3 7 'GET WORDS
ILOADR 2 3 6
ILOADR 1 3 5
LOADR 3 4
SRE &B11110000 &B11111111

'STORE NUMBER LITERAL
'PARAMETER:NUMBER

:I@STORE+
COPY ,12 .11 'GET RETURN ADDRESS
ADDI 1 .12 = % 'MODIFY RETURN ADDRESS
PR &B11111 &B11111 'GET ARGUMENTS
LOADR 4 = 'READ ARGUMENT
ISTORER 3 4 3
ISTORER 2 4 2
ISTORER 1 4 1
STORER 0 4
EXIT &B11111




'STORE NUMBER
'PARAMETER:NUMBER, ADDRESS (IN 4W FORMAT, TOP 3W ARE ALWAYS IGNORED!)

:I@STORE#
PR &B11111111 &B11111111 'GET ADDRESS AND NUMBER
'R7=ADDRESS
ISTORER 3 7 3 'STORE WORDS
ISTORER 2 7 2
ISTORER 1 7 1
STORER 0 7
EXIT &B11111111


'RANDOM
'RETURNS: 4W-INT
:I@RND
RND .11
RND .11
RND .11
RND .11
]

'LOGICAL AND
'PARAMETERS: 2 4W-INTS
'RETURNS: 4W-INT

:I@AND
PR &B11111111 &B11111111 'GET TWO NUMBERS
ANDR 0 4 = 'LOGICAL &
ANDR 1 5 =
ANDR 2 6 =
ANDR 3 7 =
SRE &B11110000 &B11111111

'LOGICAL OR
'PARAMETERS: 2 4W-INTS
'RETURNS: 4W-INT

:I@OR
PR &B11111111 &B11111111 'GET TWO NUMBERS
ORR 0 4 = 'LOGICAL OR
ORR 1 5 =
ORR 2 6 =
ORR 3 7 =
SRE &B11110000 &B11111111

'LOGICAL XOR
'PARAMETERS: 2 4W-INTS
'RETURNS: 4W-INT

:I@XOR
PR &B11111111 &B11111111 'GET TWO NUMBERS
XORR 0 4 = 'LOGICAL OR
XORR 1 5 =
XORR 2 6 =
XORR 3 7 =
SRE &B11110000 &B11111111

'LOGICAL NOT
'PARAMETER: 4W-INT
'RETURNS: 4W-INT

:I@NOT
PR &B1111 &B1111
NOT 0 = 'INVERT!
NOT 1 =
NOT 2 =
NOT 3 =
SRE &B1111 &B1111

'LEFTSHIFT ONCE
'PARAMETER: 4W-INT
'RETURNS: 4W-INT

:I@LSO
PR &B11111 &B1111
'R0-3=NUMBER
LEFTI 1 0 = 4 '<< TOP

LEFTI 1 1 = 4
ORR 4 0 = 'OR INTO BITS ABOVE

LEFTI 1 2 = 4
ORR 4 1 = 'OR INTO BITS ABOVE

LEFTI 1 3 = 4
ORR 4 2 = 'OR INTO BITS ABOVE

SRE &B1111 &B11111

'LEFTSHIFT BY PARAMETER
'PARAMETERS: 4W NUMBER , << COUNT
'RETURNS: RESULT

:I@LSP '...ILSP
PR &B11111111 &B11111111

>ILSP_LOOP
JEI 0 7 <ILSP_EXIT
FUNC &B1111 ;I@LSO 'SHIFT ONCE
REC &B1111 'GET NUMBER BACK
DEC 7 'DEC COUNTER
JUMP <ILSP_LOOP

>ILSP_EXIT
SRE &B1111 &B11111111





'RIGHTSHIFT ONCE SIGNED
:I@RSO-
PR &B11111 &B1111
ANDI &H8000 0 4 'GET UPPER BIT
FUNC &B1111 ;I@RSO+ '>>
REC &B1111 'GET NUMBER BACK
ORR 4 0 = 'OR SIGN BACK IN
SRE &B1111 &B11111

'RIGHTSHIFT ONCE UNSIGNED
'PARAMETER: 4W-INT
'RETURNS: 4W-INT
:I@RSO+
PR &B11111 &B1111
'R0-3=NUMBER
RIGHTI 1 3 = 4 'LSB >>

RIGHTI 1 2 = 4 '>>
ORR 4 3 = 'OR CARRYOVER IN

RIGHTI 1 1 = 4 '>>
ORR 4 2 = 'OR CARRYOVER IN

RIGHTI 1 0 = 4 'MSB >>
ORR 4 1 = 'OR CARRYOVER IN

SRE &B1111 &B11111






'RIGHTSHIFT BY PARAMETER SIGNED
'PARAMETERS: 4W NUMBER , >> COUNT
'RETURNS: RESULT

:I@RSP- '...IRSPS
PR &B11111111 &B11111111

>IRSPS_LOOP
JEI 0 7 <IRSPS_EXIT
FUNC &B1111 ;I@RSO- 'SHIFT ONCE
REC &B1111 'GET NUMBER BACK
DEC 7 'DEC COUNTER
JUMP <IRSPS_LOOP

>IRSPS_EXIT
SRE &B1111 &B11111111

'RIGHTSHIFT BY PARAMETER UNSIGNED
'PARAMETERS: 4W NUMBER , >> COUNT
'RETURNS: RESULT

:I@RSP+ '...IRSPU
PR &B11111111 &B11111111

>IRSPU_LOOP
JEI 0 7 <IRSPU_EXIT
FUNC &B1111 ;I@RSO+ 'SHIFT ONCE
REC &B1111 'GET NUMBER BACK
DEC 7 'DEC COUNTER
JUMP <IRSPU_LOOP

>IRSPU_EXIT
SRE &B1111 &B11111111


'LEFTSHIFT TO EDGE
:I@LSE
PR &B1111 &B1111

>ILSE_LOOP
JGI- 0 0 <ILSE_EXIT
FUNC &B1111 ;I@LSO 'SHIFT ONCE
REC &B1111 'GET NUMBER BACK
JUMP <ILSE_LOOP

>ILSE_EXIT
SRE &B1111 &B1111


'DECODE
'PARAMETERS: 4W-INT
'RETURNS: 4W-INT

:I@DECODE
;I@REDUCE
PR _01 _0
DIVI 16 0 = 1 'R0=DECODE R1=PLACE
DECODE 0 .11
;I@EXPAND+
MULI 16 1 % .11 'MULTIPLY PLACE
;I@EXPAND+
;I@LSP
EXIT _01



'MULTIPLY
'PARAMETERS: 2 4W-INTS
'RETURNS: 4W  LSW, MSW

:I@MUL '...IM
PR _0123456789 _01234567

I <IM_S7 'CLEAR OUT S REGISTER
I 8
;@ERASE

'R0-3,4-7:NUM
'R8-9:SCRATCH

'R3 MUL GROUP

JEI 0 3 <IM_R3S
JEI 0 7 <IM_R37S

'R7
MULR 3 7 8 9 '8=MS, 9=LS

'LOWER WORD
ADDR 9 <IM_S0 = 9 'ADD IN RESULT
ADDR 9 <IM_S1 = 9 'CARRY IF NEEDED

'UPPER WORD
ADDR 8 <IM_S1 = 8 'ADD IN RESULT
ADDR 8 <IM_S2 = 8 'CARRY IF NEEDED

>IM_R37S
JEI 0 6 <IM_R36S

'R6
MULR 3 6 8 9 '8=MS, 9=LS

'LOWER WORD
ADDR 9 <IM_S1 = 9 'ADD IN RESULT
ADDR 9 <IM_S2 = 9 'CARRY IF NEEDED

'UPPER WORD
ADDR 8 <IM_S2 = 8 'ADD IN RESULT
ADDR 8 <IM_S3 = 8 'CARRY IF NEEDED

>IM_R36S
JEI 0 5 <IM_R35S

'R5
MULR 3 5 8 9 '8=MS, 9=LS

'LOWER WORD
ADDR 9 <IM_S2 = 9 'ADD IN RESULT
ADDR 9 <IM_S3 = 9 'CARRY IF NEEDED

'UPPER WORD
ADDR 8 <IM_S3 = 8 'ADD IN RESULT
ADDR 8 <IM_S4 = 8 'CARRY IF NEEDED

>IM_R35S
JEI 0 4 <IM_R3S

'R4
MULR 3 4 8 9 '8=MS, 9=LS

'LOWER WORD
ADDR 9 <IM_S3 = 9 'ADD IN RESULT
ADDR 9 <IM_S4 = 9 'CARRY IF NEEDED

'UPPER WORD
ADDR 8 <IM_S4 = 8 'ADD IN RESULT
ADDR 8 <IM_S5 = 8 'CARRY IF NEEDED

>IM_R3S

'R2 MUL GROUP

JEI 0 2 <IM_R2S
JEI 0 7 <IM_R27S

'R7
MULR 2 7 8 9 '8=MS, 9=LS

'LOWER WORD
ADDR 9 <IM_S1 = 9 'ADD IN RESULT
ADDR 9 <IM_S2 = 9 'CARRY IF NEEDED
ADDR 9 <IM_S3 = 9 'CARRY IF NEEDED
ADDR 9 <IM_S4 = 9 'CARRY IF NEEDED
ADDR 9 <IM_S5 = 9 'CARRY IF NEEDED
ADDR 9 <IM_S6 = 9 'CARRY IF NEEDED

'UPPER WORD
ADDR 8 <IM_S2 = 8 'ADD IN RESULT
ADDR 8 <IM_S3 = 8 'CARRY IF NEEDED
ADDR 8 <IM_S4 = 8 'CARRY IF NEEDED
ADDR 8 <IM_S5 = 8 'CARRY IF NEEDED
ADDR 8 <IM_S6 = 8 'CARRY IF NEEDED

>IM_R27S
JEI 0 6 <IM_R26S

'R6
MULR 2 6 8 9 '8=MS, 9=LS

'LOWER WORD
ADDR 9 <IM_S2 = 9 'ADD IN RESULT
ADDR 9 <IM_S3 = 9 'CARRY IF NEEDED
ADDR 9 <IM_S4 = 9 'CARRY IF NEEDED
ADDR 9 <IM_S5 = 9 'CARRY IF NEEDED
ADDR 9 <IM_S6 = 9 'CARRY IF NEEDED
ADDR 9 <IM_S7 = 9 'CARRY IF NEEDED

'UPPER WORD
ADDR 8 <IM_S3 = 8 'ADD IN RESULT
ADDR 8 <IM_S4 = 8 'CARRY IF NEEDED
ADDR 8 <IM_S5 = 8 'CARRY IF NEEDED
ADDR 8 <IM_S6 = 8 'CARRY IF NEEDED
ADDR 8 <IM_S7 = 8 'CARRY IF NEEDED

>IM_R26S
JEI 0 5 <IM_R25S

'R5
MULR 2 5 8 9 '8=MS, 9=LS

'LOWER WORD
ADDR 9 <IM_S3 = 9 'ADD IN RESULT
ADDR 9 <IM_S4 = 9 'CARRY IF NEEDED
ADDR 9 <IM_S5 = 9 'CARRY IF NEEDED
ADDR 9 <IM_S6 = 9 'CARRY IF NEEDED
ADDR 9 <IM_S7 = 9 'CARRY IF NEEDED

'UPPER WORD
ADDR 8 <IM_S4 = 8 'ADD IN RESULT
ADDR 8 <IM_S5 = 8 'CARRY IF NEEDED
ADDR 8 <IM_S6 = 8 'CARRY IF NEEDED
ADDR 8 <IM_S7 = 8 'CARRY IF NEEDED

>IM_R25S
JEI 0 4 <IM_R2S

'R4
MULR 2 4 8 9 '8=MS, 9=LS

'LOWER WORD
ADDR 9 <IM_S4 = 9 'ADD IN RESULT
ADDR 9 <IM_S5 = 9 'CARRY IF NEEDED
ADDR 9 <IM_S6 = 9 'CARRY IF NEEDED
ADDR 9 <IM_S7 = 9 'CARRY IF NEEDED

'UPPER WORD
ADDR 8 <IM_S5 = 8 'ADD IN RESULT
ADDR 8 <IM_S6 = 8 'CARRY IF NEEDED
ADDR 8 <IM_S7 = 8 'CARRY IF NEEDED

>IM_R2S

'R1 MUL GROUP

JEI 0 1 <IM_R1S
JEI 0 7 <IM_R17S

'R7
MULR 1 7 8 9 '8=MS, 9=LS

'LOWER WORD
ADDR 9 <IM_S2 = 9 'ADD IN RESULT
ADDR 9 <IM_S3 = 9 'CARRY IF NEEDED
ADDR 9 <IM_S4 = 9 'CARRY IF NEEDED
ADDR 9 <IM_S5 = 9 'CARRY IF NEEDED
ADDR 9 <IM_S6 = 9 'CARRY IF NEEDED
ADDR 9 <IM_S7 = 9 'CARRY IF NEEDED

'UPPER WORD
ADDR 8 <IM_S3 = 8 'ADD IN RESULT
ADDR 8 <IM_S4 = 8 'CARRY IF NEEDED
ADDR 8 <IM_S5 = 8 'CARRY IF NEEDED
ADDR 8 <IM_S6 = 8 'CARRY IF NEEDED
ADDR 8 <IM_S7 = 8 'CARRY IF NEEDED

>IM_R17S
JEI 0 6 <IM_R16S

'R6
MULR 1 6 8 9 '8=MS, 9=LS

'LOWER WORD
ADDR 9 <IM_S3 = 9 'ADD IN RESULT
ADDR 9 <IM_S4 = 9 'CARRY IF NEEDED
ADDR 9 <IM_S5 = 9 'CARRY IF NEEDED
ADDR 9 <IM_S6 = 9 'CARRY IF NEEDED
ADDR 9 <IM_S7 = 9 'CARRY IF NEEDED

'UPPER WORD
ADDR 8 <IM_S4 = 8 'ADD IN RESULT
ADDR 8 <IM_S5 = 8 'CARRY IF NEEDED
ADDR 8 <IM_S6 = 8 'CARRY IF NEEDED
ADDR 8 <IM_S7 = 8 'CARRY IF NEEDED

>IM_R16S
JEI 0 5 <IM_R15S

'R5
MULR 1 5 8 9 '8=MS, 9=LS

'LOWER WORD
ADDR 9 <IM_S4 = 9 'ADD IN RESULT
ADDR 9 <IM_S5 = 9 'CARRY IF NEEDED
ADDR 9 <IM_S6 = 9 'CARRY IF NEEDED
ADDR 9 <IM_S7 = 9 'CARRY IF NEEDED

'UPPER WORD
ADDR 8 <IM_S5 = 8 'ADD IN RESULT
ADDR 8 <IM_S6 = 8 'CARRY IF NEEDED
ADDR 8 <IM_S7 = 8 'CARRY IF NEEDED

>IM_R15S
JEI 0 4 <IM_R1S

'R4
MULR 1 4 8 9 '8=MS, 9=LS

'LOWER WORD
ADDR 9 <IM_S5 = 9 'ADD IN RESULT
ADDR 9 <IM_S6 = 9 'CARRY IF NEEDED
ADDR 9 <IM_S7 = 9 'CARRY IF NEEDED

'UPPER WORD
ADDR 8 <IM_S6 = 8 'ADD IN RESULT
ADDR 8 <IM_S7 = 8 'CARRY IF NEEDED

>IM_R1S

'R0 MUL GROUP

JEI 0 0 <IM_R0S
JEI 0 7 <IM_R07S

'R7
MULR 0 7 8 9 '8=MS, 9=LS

'LOWER WORD
ADDR 9 <IM_S3 = 9 'ADD IN RESULT
ADDR 9 <IM_S4 = 9 'CARRY IF NEEDED
ADDR 9 <IM_S5 = 9 'CARRY IF NEEDED
ADDR 9 <IM_S6 = 9 'CARRY IF NEEDED
ADDR 9 <IM_S7 = 9 'CARRY IF NEEDED

'UPPER WORD
ADDR 8 <IM_S4 = 8 'ADD IN RESULT
ADDR 8 <IM_S5 = 8 'CARRY IF NEEDED
ADDR 8 <IM_S6 = 8 'CARRY IF NEEDED
ADDR 8 <IM_S7 = 8 'CARRY IF NEEDED

>IM_R07S
JEI 0 6 <IM_R06S

'R6
MULR 0 6 8 9 '8=MS, 9=LS

'LOWER WORD
ADDR 9 <IM_S4 = 9 'ADD IN RESULT
ADDR 9 <IM_S5 = 9 'CARRY IF NEEDED
ADDR 9 <IM_S6 = 9 'CARRY IF NEEDED
ADDR 9 <IM_S7 = 9 'CARRY IF NEEDED

'UPPER WORD
ADDR 8 <IM_S5 = 8 'ADD IN RESULT
ADDR 8 <IM_S6 = 8 'CARRY IF NEEDED
ADDR 8 <IM_S7 = 8 'CARRY IF NEEDED

>IM_R06S
JEI 0 5 <IM_R05S

'R5
MULR 0 5 8 9 '8=MS, 9=LS

'LOWER WORD
ADDR 9 <IM_S5 = 9 'ADD IN RESULT
ADDR 9 <IM_S6 = 9 'CARRY IF NEEDED
ADDR 9 <IM_S7 = 9 'CARRY IF NEEDED

'UPPER WORD
ADDR 8 <IM_S6 = 8 'ADD IN RESULT
ADDR 8 <IM_S7 = 8 'CARRY IF NEEDED

>IM_R05S
JEI 0 4 <IM_R0S

'R4
MULR 0 4 8 9 '8=MS, 9=LS

'LOWER WORD
ADDR 9 <IM_S6 = 9 'ADD IN RESULT
ADDR 9 <IM_S7 = 9 'CARRY IF NEEDED

'UPPER WORD
ADDR 8 <IM_S7 = 8 'ADD IN RESULT

>IM_R0S

'PUT LOWER WORD ON STACK
;I@LIT+ <IM_S3
;I@LOAD#

'PUT UPPER WORD ON STACK
;I@LIT+ <IM_S7
;I@LOAD#

EXIT _0123456789



'DIVIDE, UNSIGNED
:I@DIV+
;I@DM+
;I@DROP 'DROP MOD RESULT
]

'MOD, UNSIGNED
:I@MOD+
;I@DM+
;I@SWAP
;I@DROP 'DROP DIV RESULT
]

'DIVIDE, SIGNED
:I@DIV-
;I@DM-
;I@DROP 'DROP MOD RESULT
]

'MOD, SIGNED
:I@MOD-
;I@DM-
;I@SWAP
;I@DROP 'DROP DIV RESULT
]

'DIVIDE AND MOD, SIGNED
:I@DM- '...IDM-
PR &B1111111111 &B11111111 'GET N AND D

'GET SIGNS OF N AND D
FUNC &B1111 ;I@SIGN 'SIGN OF N
COPY ,11 8 'R8=N SIGN
;I@DROP 'DROP SIGN

FUNC &B11110000 ;I@SIGN 'SIGN OF D
COPY ,11 9 'R9=D SIGN
;I@DROP 'DROP SIGN

'Q=N*D
'R=N

'R8=Q SIGN
'R9=R SIGN
MULR 9 8 = = 'GET Q SIGN

FUNC &B11111111 ;I@ABS 'SEND N AND D, CONVERT BOTH TO POSITIVE
;I@SWAP
;I@ABS
;I@SWAP
;I@DM+ 'DO DIVMOD

'MULTIPLY R BY SIGN
R 9
;I@EXPAND-
;I@MUL
;I@DROP 'DROP MSW
'MULTIPLY Q BY SIGN
;I@SWAP
R 8
;I@EXPAND-
;I@MUL
;I@DROP
;I@SWAP
EXIT &B1111111111


'DIVIDE AND MOD WITH BINARY LONG DIVISION
'PARAMETERS: 2 4W-INT
'RETURNS: 4W-INT QUOTIENT, REMAINDER
:I@DM+ '...NIDM
;I@STORE+ <IDM_D 'STORE AWAY DIVISOR
;I@STORE+ <IDM_N 'STORE AWAY NUMERATOR

PE &B1111111111

'R0-3:QUOTIENT
'R4-7:REMAINDER

'RESET REMAINDER
MOVE 0 4
MOVE 0 5
MOVE 0 6
MOVE 0 7


MOVE 63 8 'MAIN LOOP COUNTER

>NIDM_LOOP
JEI -1 8 <NIDM_END 'END?

FUNC &B1111 ;I@LSO 'LEFT SHIFT Q ONCE
REC &B1111

FUNC &B11110000 ;I@LSO 'LEFT SHIFT R ONCE

;I@LIT# &H8000 0 0 0 'GET BIT OF N
;I@LOAD+ <IDM_N
;I@AND
;I@TRUE 'BIT GOT

;I@OR 'OR INTO R
;I@DUP 'CREATE A COPY
REC &B11110000 'RECOVER R

'CHECK IF R >= D

;I@LOAD+ <IDM_D 'PUT D ON STACK
;I@< 'CHECK IF R < D
'COPY ,11 9 'GET RESULT
';I@DROP 'DELETE RESULT FROM STACK

'IF IT'S 0, R>=D
'IF IT'S 1, R<D

JEI 1 ,11 <NIDM_SUBSKIP

>NIDM_SUB
FUNC &B11110000 ;I@LOAD+ <IDM_D 'GET R AND D
;I@SUB 'SUBTRACT D
;I@DROP 'DROP CARRY
REC &B11110000 'STORE IN R

FUNC &B1111 ;I@LIT+ 1 'GET Q AND SET LEAST SIGNIFICANT BIT TO 1
;I@OR
REC &B1111 'GET NEW Q

>NIDM_SUBSKIP
DEC 8 'DECREMENT LOOP COUNTER
;I@LOAD+ <IDM_N
;I@LSO 'SHIFT N OVER
;I@STORE+ <IDM_N

;I@DROP
JUMP <NIDM_LOOP


>NIDM_END
SRE &B11111111 &B1111111111


































'ADD
'PARAMETERS: TWO 4W-INTS
'RETURNS: ADD, CARRY

:I@ADD
PR &B1111111111 &B11111111
'R0-3:FIRST NUMBER
'R4-7:SECOND NUMBER
MOVE 0 9

ADDR 3 7 = 8 'GET 1ST RESULT WORD
ADDR 8 6 = 8 'ADD IN CARRY
ADDR 8 5 = 8 'ADD IN CARRY
ADDR 8 4 = 8 'ADD IN CARRY

ORR 8 9 =

ADDR 2 6 = 8 'GET 2ND RESULT WORD
ADDR 8 5 = 8 'ADD IN CARRY
ADDR 8 4 = 8 'ADD IN CARRY

ORR 8 9 =

ADDR 1 5 = 8 'GET 3RD RESULT WORD
ADDR 8 4 = 8 'ADD IN CARRY

ORR 8 9 =

ADDR 0 4 = 8 'GET 4TH RESULT WORD

ORR 8 9 =

S &B11110000 'SEND RESULT
R 9 'SEND CARRY
;I@EXPAND+ 'EXPAND CARRY
EXIT &B1111111111



'SUBTRACT
'PARAMETERS: TWO 4W-INTS
'RETURNS: SUB, BORROW FLAG

:I@SUB
PR &B1111111111 &B11111111
'R0-3:FIRST NUMBER
'R4-7:SECOND NUMBER
MOVE 0 9

SUBR 7 3 7 8 'GET 1ST RESULT WORD
ADDR 8 6 = 8 'ADD IN CARRY
ADDR 8 5 = 8 'ADD IN CARRY
ADDR 8 4 = 8 'ADD IN CARRY

ORR 8 9 =

SUBR 6 2 6 8 'GET 2ND RESULT WORD
ADDR 8 5 = 8 'ADD IN CARRY
ADDR 8 4 = 8 'ADD IN CARRY

ORR 8 9 =

SUBR 5 1 5 8 'GET 3RD RESULT WORD
ADDR 8 4 = 8 'ADD IN CARRY

ORR 8 9 =

SUBR 4 0 4 8 'GET 4TH RESULT WORD

ORR 8 9 =

S &B11110000 'SEND RESULT
R 9 'SEND BORROW
;I@EXPAND+ 'EXPAND CARRY
EXIT &B1111111111

'GREATER
'PARAMETERS: 4W-INTS
'RETURNS IF A>B

:I@> '...I>
;I@SWAP
;I@<
]

'LESS
'PARAMETERS: 4W-INTS
'RETURNS IF A>B

:I@<
PR &B11111111 &B11111111
FUNC &B11111111 ;I@SUB 'SUBTRACT NUMBERS
;I@SWAP
;I@DROP 'DROP RESULT, ONLY BORROW'S NEEDED
EXIT &B11111111

'EQUAL
'PARAMETERS: 4W-INTS
'RETURNS IF A>B

:I@=
PR &B11111111 &B11111111
FUNC &B11111111 ;I@SUB 'SUBTRACT NUMBERS
;I@DROP 'DROP CARRY
;I@TRUE 'GET TRUE
;I@LIT+ 1 'XOR WITH 1
;I@XOR
EXIT &B11111111

'TRUE
'PARAMETER: 4W-INT
'RETURNS: 4W-INT

:I@TRUE
PR &B1111 &B1111
'OR ALL BITS TOGETHER
ORR 0 1 =
ORR 2 3 =
ORR 1 3 =
TRUE 3 .11 'RETURN RESULT
;I@EXPAND+ 'EXPAND TO 4W
EXIT &B1111

'SIGN
'RETURNS -1, 0 OR 1 INDICATING THE SIGN

:I@SIGN
PR &B11111 &B1111
ANDI &H8000 0 4 'KEEP A COPY OF SIGN BIT
JNI 0 4 <IS_NEGATIVE 'NEGATIVE?
FUNC &B1111 ;I@TRUE 'PERFORM TRUE FUNCTION
REC &B1111 'GET RESULT
SRE &B1111 &B11111 'SEND POSITIVE OR 0

>IS_NEGATIVE
;I@LIT- -1 'SEND -1
EXIT &B11111

'TWO
'PARAMETER: 4W-INT
'RETURNS: 4W-INT

:I@TWO
;I@NOT 'INVERT NUMBER
;I@LIT+ 1 'ADD 1
;I@ADD
;I@DROP 'DROP CARRY
]

'ABSOLUTE
'PARAMETER: 4W-INT
'RETURNS: 4W-INT
:I@ABS
PR &B1111 &B1111
JGI- 0 0 <IABS_CASE 'NEGATIVE?
SRE &B1111 &B1111 'POSITIVE, DO NOTHING

>IABS_CASE
FUNC &B1111 ;I@TWO 'INVERT!
EXIT &B1111

'BIT EXTRACT
'PARAMETER: 4W-INT NUMBER, BIT
'RETURNS: 4W-INT BIT
:I@BITEX
;I@RSP+ 'RIGHTSHIFT TO BIT
;I@LIT+ 1 'AND WITH 1
;I@AND
]

'BIT SET
'PARAMETER: 4W-INT NUMBER, BIT
'RETURNS: 4W-INT
:I@BITSET
;I@LIT+ 1 'CREATE ORWORD
;I@SWAP 'PLACE BELOW RSP AMOUNT
;I@LSP 'LEFTSHIFT BY BITS
;I@OR 'OR INTO NUMBER
]

'BIT FLIP
'PARAMETER: 4W-INT NUMBER, BIT
'RETURNS: 4W-INT
:I@BITFLIP
;I@LIT+ 1 'CREATE XORWORD
;I@SWAP 'PLACE BELOW RSP AMOUNT
;I@LSP 'LEFTSHIFT BY BITS
;I@XOR 'XOR INTO NUMBER
]

'BIT CLEAR
'PARAMETER: 4W-INT NUMBER, BIT
'RETURNS: 4W-INT
:I@BITCLEAR
;I@LIT+ 1 'CREATE ANDWORD
;I@SWAP 'PLACE BELOW RSP AMOUNT
;I@LSP 'LEFTSHIFT BY BITS
;I@NOT 'INVERT
;I@AND 'AND INTO NUMBER
]

'PRINT WITH BASE SIGNED
'PARAMETERS: 4W-INT NUMBER, BASE

:I@PRINT- '...IP-
PR &B111111111 &B11111111
'R0-3=NUMBER
'R7=BASE
FUNC &B1111 ;I@SIGN 'GET THE SIGN OF THE NUM
COPY ,11 8 'R8=SIGN
;I@DROP
JEI &HFFFF 8 <IP-_NEGATIVE

FUNC &B11111111 ;I@GD 'GET DIGITS
DEC ,11 'DEC LENGTH
;@MPRINT
EXIT &B111111111

>IP-_NEGATIVE
FUNC &B1111 ;I@TWO 'GET POSITIVE PART
REC &B1111
FUNC &B11111111 ;I@GD 'GET DIGITS
COPY .11 .12
DEC ,11 'DEC LOCATION
COPY .12 .11
;@MPRINT
EXIT &B111111111

'PRINT WITH BASE UNSIGNED
'PARAMETERS: 4W-INT NUMBER, BASE

:I@PRINT+
;I@GD 'CONVERT NUMBER
DEC ,11 'DEC LENGTH
;@MPRINT
]

'INPUT 4W-INT NUMBER WITH BASE
'PARAMETER: 4W-INT BASE
'RETURNS: 4W-INT NUMBER

:I@INPUT '...II
PR &B1111111 &B1111
'R3=BASE
I ;IGD_LOC 'PASS LOCATION
I 48 'PASS LENGTH
;@INPUT 'GET NUMBER

REC &B110000 'R4=LOCATION, R5=LENGTH
ADDR 4 5 6 % 'R6=END OF STRING
STOREIR !/ 6 'PUT A SLASH THERE
INC 6
STOREIR 0 6 'PUT A NULL AFTER
INC 6
INC 5 'INC LENGTH
R 4 'SEND LOCATION
;I@EXPAND+
FUNC &B1111 ;I@LOAD$ 'LOAD NUMBER
EXIT &B1111111


'NUMBER BUFFER PRINT
'PRINTS WHATEVER IS IN NUMBER BUFFER

:I@NB_PRINT
I ;IGD_LOC 'GET LOCATION
I !/ 'GET END CHR
;@BLOCK2 'GET BLOCK
;@MPRINT 'PRINT
]















'EMULATOR



























'INITIAL PROGRAM LOADER

:@IPL '...IPL
PE &B110000000000000
'TRUE <IPL_BT = 'ENSURE DOUBLE EMULATION DOES NOT HAPPEN
;@13 'SET UP SCREENS
;@14

>IPL_LL
I 0 'STARTING LOCATION
;@LOADFILENAME 'LOAD A PROGRAM
ORR .11 = = 'OR RESULTS TOGETHER
JEI 0 .11 <IPL_LL 'REPEAT?

>IPL_ESKIP
;@CLS 'ERASE TERMINAL
RE &B110000000000000

REFR 'REFRESH THE DISPLAY
I ;FILE 'RESET INPUT
;@BLOCK
;@ERASE
'ERASE THE STACKS
MOVE &H40 0

>IPL_ELOOP
JEI 0 0 <IPL_EXIT 'EXIT?
I 0 'PUSH ZERO TO DATA STACK
PUSHI 0 12 'PUSH ZERO TO RETURN STACK
DEC 0
JUMP <IPL_ELOOP

>IPL_EXIT
MOVE 0 0 'RESET R0
MOVE &HF000 11 'RESET STACKS
MOVE &H0000 12 'RESET STACKS

JUMP &H100 'RESET IP



>BNM_NUM1 'BUTTON DATA TABLE
1 2 4 8 16 32 64 128 256 512 2048 4096
>BNM_BTN
$
>BNM_NUM2
1 2 4 8 16 32 64 128 256 512 2048 4096

:KB_SC 'SPECIAL CHARACTER SELECTOR
$
$
$
$
$
$
$
$
$
$
>KB_HEX
$0000
>KB_DEC
$00000OKBACKCHRNAV
$
$
$
>KB_CHR
$
$
:KB_KEYS 'NON-KEYS ARE CHR &HE2A9
$
$
$
$
$£｀^´£｀^´
>KB_LETTERSTART
$1-+2!?3A-+N!?I
$$/†∞=€$V/LX=€
$
${®%ΨΦΠ｜}{®%QUP}
$(4Θ5Ξ6)(HKCOBMR)
$[©_ΓΣΔ@][©_GDJ@]
$
$~¨"¶'‡&˚~¨Y"W'F&˚
$<7*§8#9><T*§EZ#S>
>KB_LETTEREND
$,.:;,.:;
$
$
$
:KB_LASTLETTER
$0  
$ 
$
$
$
$
$

:LIB_END 'END OF LIBRARY CODE
+&H320
:SCREEN_END 'END OF TERMINAL
*&H100
JUMP ;@IPL 'SET UP JUMP TO IPL
*&H0 'RESET TO ADDRESS 0

