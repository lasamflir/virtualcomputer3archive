'ADVANCED VIRTUAL COMPUTER 3
ACLS
BGMSTOP
XSCREEN 3
COLOR 15,0
CLS
GCLS
DISPLAY 0
COLOR 5,0
LOCATE 19,13
PRINT "INITIALISING"
LOCATE 23,15
PRINT "AVC3";
XON EXPAD
WFRESH%=0
LDLY%=0 'LABEL DELAY
CDLY%=0 'CODE DELAY
DEBUGENABLE=RESULT

S1%=#A
STYT=2
DBT=0 'DEBUG STICK DEADZONE

ZL%=#ZL
ZR%=#ZR
IF !DEBUGENABLE THEN
S1%=#X
DBT=0.5 'REDUCE SENSITIVITY
STYT=DBT 'STICK Y THRESHOLD FOR DEBUG MENU
'REMAP ZL AND ZR TO A+L AND A+R
ZL%=#A+#L
ZR%=#A+#R
ENDIF

TYPE=0
LVERB%=0
RVERB%=0

ALTVIEW=1

'ARRAYS
DIM RAM%[65536] 'SYSTEM RAM
DIM SOURCE$[65536] 'SOURCE CODE
DIM TYPE%[65536]'DATA TYPE ARRAY
DIM BP%[65536]'BREAKPOINT ARRAY
DIM REG%[16]'REGISTERS

REG%[11]=&HF000 'INITIALISE STACK POINTER
REG%[13]=&H100 'INITIALISE UPPER DISPLAY
REG%[14]=&HA000 'INITIALISE LOWER DISPLAY
REG%[15]=&H100 'INITIALISE INSTRUCTION POINTER
DIM DSTACK%[0]'DEBUG DEST STACK
DIM SSTACK%[0]'DEBUG SOURCE STACK
DIM ARG%[4]'ARGUMENTS
DIM LABEL$[65536,3]'LABEL,GLOBAL FLAG,PROGRAM NAME
DIM CLL$[0]'STACK FOR STORING LOCAL LABELS DURING COMPILATION
DIM CGL$[0]'STACK FOR STORING GLOBAL LABELS DURING COMPILATION
DIM RU%[0]'REGISTER USE STACK

NAME$="SLOT 1"

'INSTRUCTION SET

'ADD STOREIR AND STOREIM!
IS$=" 000.HALT*0 001.MOVE*2 002.COPY*2 003.SWAP*2 004.JUMP*1 005.REFR*0 006.VSYNCI*1 007.VSYNCR*1 008.DEC*1 009.INC*1 010.COMPILE*4 011.LOAD*4 012.DATASAVE*4 013.SAVE*4 014.LOADR*2 015.LOADM*2 016.ILOADR*3 017.RLOADR*3 018.STORER*2 019.STOREM*2 020.ISTORER*3 021.RSTORER*3 022.ADDR*4 023.ADDI*4 024.SUBR*4 025.SUBI*4 026.MULR*4 027.MULI*4 028.DIVR*4 029.DIVI*4 030.TWO*2 031.ANDR*3 032.ANDI*3 033.ORR*3 034.ORI*3 035.XORR*3 036.XORI*3 037.NOT*2 038.LEFTR*4 039.LEFTI*4 040.RIGHTR*4 041.RIGHTI*4 042.TRUE*2 043.SIGN*2 044.RND*1 045.TOUCH*3 046.CLIPR*2 047.CLIPI*2 048.CLIPL*1 049.BUTTON*1 050.MIL*2 051.TIME*3 052.DATE*3 053.OUT*1 054.BEEP*2 055.JER*3 056.JEI*3 057.JNR*3 058.JNI*3 059.JGR+*3 060.JGR-*3 061.JGI+*3 062.JGI-*3 063.JLR+*3 064.JLR-*3 065.JLI+*3 066.JLI-*3 067.FORKR+*4 068.FORKR-*4 069.FORKI+*4 070.FORKI-*4 071.PUSHR*2 072.PUSHI*2 073.POP*2 074.R*1 075.I*1 076.G*1 077.PSR*1 078.RSR*1 079.S*1 080.REC*1 081.PE*1 082.RE*1 083.PR*2 084.SR*2 085.[*1 086.]*0 087.EXIT*1 088.FUNC*2 089.SRE*2 090.STOREIR*2 091.STOREIM*2 092.SDIVR*4 093.SDIVI*4 094.ROLR*3 095.ROLI*3 096.RORR*3 097.RORI*3 098.JAR*3 099.JAI*3 100.DECODE*2 101.MCOPYR*3 102.MCOPYI*3 103.MFILLR*3 104.MFILLI*3"

'INSTRUCTION SET
'IS$=" 00.HALT-0 01.MOVE-2 02.SWAP-2 03.COPY-2 04.JUMP-1 05.REFR-0 06.VSYNCI-1 07.VSYNCR-1 08.INC-1 09.DEC-1 10.COMPILE-4 11.LOAD-4 12.DATASAVE-4 13.SAVE-4 14.LOADR-2 15.LOADM-2 16.ILOADR-3 17.RLOADR-3 18.STORER-2 19.STOREM-2 20.ISTORER-3 21.RSTORER-3 22.ADDR-4 23.ADDI-4 24.SUBR-4 25.SUBI-4 26.MULR-4 27.MULI-4 28.DIVR-4 29.DIVI-4 30.TWO-2 31.ANDR-3 32.ANDI-3 33.ORR-3 34.ORI-3 35.XORR-3 36.XORI-3 37.NOT-2 38.LEFTR-3 39.LEFTI-3 40.RIGHTR-3 41.RIGHTI-3 42.TOUCH-3 43.CLIPR-2 44.CLIPI-2 45.CLIPL-1 46.BUTTON-1 47.MIL-2 48.TIME-3 49.DATE-3 50.OUT-1 51.BEEP-2 52.JER-3 53.JEI-3 54.JNR-3 55.JNI-3 56.JGR-3 57.JGI-3 58.SGR-3 59.SGI-3 60.JLR-3 61.JLI-3 62.SLR-3 63.SLI-3 64.PUSHR-2 65.PUSHI-2 66.POP-2 67.R-1 68.I-1 69.G-1 70.PSR-1 71.RSR-1 72.S-1 73.REC-1 74.PE-1 75.RE-1 76.PR-2 77.SR-2 78.[-1 79.]-0 80.EXIT-1 81.FUNC-2 82.SRE-2 83.STOREIR-2 84.STOREIM-2 85.RND-1 86.TRUE-2"


'INTRO TEXT STRING
'I REALISE THIS ISN'T TO EVERYONE'S TASTES
'COMMENT OUT THE FOLLOWING LINE TO DISABLE

INTRO$="Repeating these is pure lazinessゞGaming is really SWAG!ゞLEGALISE AWOO!ゞRIP epic gamer intro text on DiscordゞToggling thousands of switches...ゞYou are now thinking manuallyゞLamps in videogames use real electricityゞIn SPECTACULAR 3-D!ゞhttps://youtu.be://dQw4w9WgXcQゞThank you, micro menゞla .eivn cu vecnu loi flira cinta ka'a lo do patfuku zo'oゞE L E C T R I F Y I N GゞゞDiscordifying the intro textゞMachine code programming is anarcho-primitivismゞEゞMov is turing-completeゞAren't you glad AVC3 has more than 1 instruction?ゞOnly hipsters code in assemblyゞAo8oA!ゞA113ゞ;3ゞThese random slogans aren't endearing nor cute.ゞPWN N00B5 U G07 7HI5ゞ'INTRO TEXT STRINGゞ'I REALISE THIS ISN'T TO EVERYONE'S TASTESゞ'COMMENT OUT THE FOLLOWING LINE TO DISABLEゞ70% recycledゞThis statement is falseゞNow in colour-o-visionゞStop recompiling for more slogansゞ+[]ゞ.i do samtcifi'iゞ#0 Minesweeper platformゞACV3!!ゞSimply the most poggers of programming platformsゞI'd like to interject for a moment...ゞ/"+CHR$(10)+"@ゞPowered by marmaladeゞThe word today is COMPUTERゞNot porfreading these is pure lzainessゞnew VC just droppedゞSoup of the day implies soup of the nightゞRIP JOHN CONWAYゞ*Holds up spork* im so random xdゞ.11 = = %ゞHit me with your drugs and I'll be just fineゞIt'd be crazy if there was AVC3 for AVC3!...waitゞFNUNGLING THE BLIPPITYBLOPS!1ゞwhat if zelda was a girlゞwwiting wots of code uwuゞOWOゞFINALLY!"+CHR$(10)+"NEW LIBRARY CODEゞMake a little birdhouse in your soulゞGod's gift to computingゞ© nobodyゞCelebrating 4 yearsゞExactly 2 years A.F.D. (After Finding Dory)ゞNow with random music too!ゞPure water bangsゞOMG this is so smileBASICcore!ゞStop recompiling for different musicゞBased on a true storyゞNow I am become Barbie girl, in Barbie Worlds.ゞ[Name]'s [Noun]ゞShortlistedゞHmm today I will putゞthe other half of this meme as another entryゞDon't bring back ÞornゞAs predicted in George Orwell's 1984ゞNow with USB-CゞThey targeted gamers."+CHR$(10)+CHR$(10)+"Gamers.ゞPro tip: write programs for AVC3 to run.ゞPro tip: use debug mode to see what's wrong.ゞHoly hell!ゞGoogle en passantゞ"

'VARIABLES
CLP$=CLIPBOARD()'CLIPBOARD
DEBUG%=0'DEBUG MODE SWITCH
LIBNAME$="PRG2:-----------LIB"'LIBRARY NAME
UCSTART=0 'USER CODE START
CYCLES%=0'CYCLE COUNT
LASTL=0'LAST LABEL
CNUM=0'COMPILATION NUMBER (0 FOR LIB, 1 FOR USER PROGRAM, 2 FOR FIRST COMPILATION AFTER, AND SO ON...)
RFVSYNC=0 'REFRESH VSYNC

'NEW READ/WRITE VIEW

'READ/WRITE VIEW
'THESE ARE QUEUES

DIM ADR%[4] 'ADDRESS
DIM DTT%[4] 'DATA
DIM RW%[4] 'R/W '1=R, 2=W
DIM INST%[4] 'INSTRUCTION
READA=0 'LAST READ ADDRESS
WRITEA=0 'LAST WRITE ADDRESS
LMM%=0 'LEFT MEMORY MODE
RMM%=0 'RIGHT MEMORY MODE

'THESE ARE QUEUES. THEY ARE FILLED UP AS INSTRUCTIONS ARE EXECUTED SO EVERY READ/WRITE OF AN INSTRUCTION MAY BE TRACKED.

'IMMEDIATELY BEFORE EVERY NEW INSTRUCTION, THEY ARE ERASED

'DEFAULT DEBUG MODE VALUES

'CORE
PAUSE=1'PAUSE
RFM%=1'REFRESH MODE
HEX=1'HEXADECIMAL
INSV=1'INSTRUCTION VIEW
LAV=1'LABEL VIEW
RWV=1'READ/WRITE VIEW
AV=1'ARGUMENT VIEW
WV=0
GRAYMODE%=0 'GRAY MODE
GRAYT%=0 'TEMP VARIABLE FOR GRAY OVERRIDE

OUT$=""'OUTPUT STRING

'LEFT AND RIGHT SIDES
LRV=1'LEFT REGISTER VIEW
RRV=0'RIGHT REGISTER VIEW
LPM=0'LEFT POINTER MODE
RPM=1'RIGHT POINTER MODE
LSVAD=1'LEFT STACK VIEW/AUX DISPLAY
RSVAD=1'RIGHT STACK/AUX DISPLAY
LSVM=1'LEFT MODE: STACK VIEW
RSVM=1'RIGHT MODE: STACK VIEW
LADD=12'LEFT ADDRESS/REGISTER
RADD=11'RIGHT ADDRESS/REGISTER
LBASE=0'LEFT STACK BASE
RBASE=&HF000 'RIGHT STACK BASE
LOFF=0'LEFT OFFSET
ROFF=0'RIGHT OFFSET
LPD=1'LEFT POINTER DEPTH
RPD=1'RIGHT POINTER DEPTH
LBR=0'LEFT BYPASS REGISTER
RBR=0'RIGHT BYPASS REGISTER
WATCH=0 'WATCH ADDRESS
WATCH2=0 'WATCH ADDRESS

BYTE=0 'CURRENT BYTE OF MEMORY
LAST$="" 'LAST WORD
MODE=0
LASTN=0 'LAST THING WRITTEN TO RAM

'MPU+RPU
MBIN=0'BINARY VIEW

'PARSE ARGUMENT COUNT INTO AN ARRAY FOR SPEED
DIM AC%[0]
IN=0
WHILE TRUE
POS1=INSTR(IS$," "+FORMAT$("%03D",IN))
IF POS1==-1 THEN BREAK
POS2=INSTR(POS1,IS$,"*")
ARGC=VAL(IS$[POS2+1])
PUSH AC%,ARGC
'PRINT MID$(IS$,POS1,POS2-POS1+2)
INC IN
WEND

'PARSE INTRO STRING INTO STRING ARRAY
DIM INTT$[0]
MSTART=0
WHILE TRUE
MEND=INSTR(MSTART,INTRO$,"ゞ")
IF MEND==-1 THEN BREAK
MLENGTH=MEND-MSTART
PUSH INTT$,MID$(INTRO$,MSTART,MLENGTH)
'PRINT MID$(INTRO$,MSTART,MLENGTH)
MSTART=MEND+1
WEND

DISPLAY 0
CLS

IPL=0 'USE IPL?

'START OF PROGRAM LOADING SEQUENCE
@LOADER
COLOR 15,0
CLS
LOCATE 0,0
COLOR 15,9
PRINT "ADVANCED VIRTUAL COMPUTER 3"
PRINT 
COLOR 15,0
PRINT " SLOT  FILE  IPL";
COLOR 13,0
PRINT "  VERBOSE MODE"
COLOR 7,0
PRINT " PREMIUM VERBOSE MODE"
COLOR 3,0
PRINT "Z DELAY PROMPT Z 1 FRAME"
COLOR 11,0
PRINT " DEBUG SLOT  RUN SLOT"

COLOR 15,0

DISPLAY 1
'FOR I=0 TO 14
'PRINT ""
'PRINT ""
'NEXT
DISPLAY 0
REPEAT
R=GETBTN()
UNTIL (R AND S1%) OR (R AND #B) OR (R AND #Y) OR (R AND #UP) OR (R AND #DOWN)


IF (R AND #UP) THEN DEBUG%=1:BK=1:RFM%=0:GOTO @DBBSKIP
IF (R AND #DOWN) THEN DEBUG%=0:GOTO @DBBSKIP
IF (R AND #L) THEN LVERB%=1
IF (R AND #R) THEN RVERB%=1
IF (R AND #LEFT) THEN LVERB%=2
IF (R AND #RIGHT) THEN RVERB%=2
IF (R AND ZR%) THEN CDLY%=1:LDLY%=1
IF (R AND ZL%) THEN INPUT "LABEL DELAY:",LDLY%:INPUT "COMPILE DELAY:",CDLY%

IF (R AND S1%) THEN
NAME$="SLOT 1"
ELSEIF (R AND #B) THEN
FILES
INPUT NAME$
LOAD "PRG1:"+NAME$
IF RESULT==0 THEN GOTO @LOADER
ELSEIF (R AND #Y) THEN
IPL=1
ENDIF

CLS
PRINT "DEBUG MODE:  ON  OFF  UNPAUSED  NO BKPT"
COLOR 13,1
PRINT "REFRESH MODE:ON OFF RW [ ] [] SC"
COLOR 15,1

WHILE TRUE
BTN=GETBTN()
DBBTN=BTN AND 240 'FILTER OUT AXYB
RFBTN=BTN AND 783 'FILTER OUT DPAD+L
IF DBBTN==#A THEN DEBUG%=1:BK=1:BREAK
IF DBBTN==#B THEN DEBUG%=0:PAUSE=0:BK=0:BREAK
IF DBBTN==#X THEN DEBUG%=1:PAUSE=0:BK=1:BREAK
IF DBBTN==#Y THEN DEBUG%=1:PAUSE=0:BK=0:BREAK
WEND
IF RFBTN==#UP THEN RFM%=0
IF RFBTN==#DOWN THEN RFM%=2
IF RFBTN==#LEFT THEN RFM%=4
IF RFBTN==#RIGHT THEN RFM%=5
IF RFBTN==#L THEN RFM%=3
IF RFBTN==#R THEN RFM%=6

@DBBSKIP
DISPLAY 0
CLS
CSTARTT%=MILLISEC
DISPLAY 1
COLOR 15,1
IF DEBUG% THEN PRINT CLP$
DISPLAY 0

FUNNY
PRINT
COLOR 15,9
PRINT "LOADING CODE LIBRARY...";

DISPLAY 0
LOAD LIBNAME$,FALSE
UCSTART=COMPILE(0,2,LVERB%,1)

IF !IPL THEN
PRINT 
PRINT
FUNNY
COLOR 15,3
PRINT
PRINT "LOADING "+NAME$+"...";
DISPLAY 1
PRINT 
DISPLAY 0

INC CNUM
USERCODE=COMPILE(UCSTART,1,RVERB%,1)
ENDIF

CENDT%=MILLISEC

IF BUTTON(0)==#A THEN
COLOR 15,0
PRINT
PRINT "VISUAL MEMORY PROFILE ACTIVATED"
LOFF=&HFFE5
ROFF=&HFFE5
LMM%=1
RMM%=2
LSVM=0
RSVM=0
RRV=1
WHILE BUTTON(0)
WEND
ENDIF

IF BUTTON(0)==#B THEN
COLOR 15,0
PRINT
PRINT "AVC1 PROFILE ACTIVATED"
RRV=1
WHILE BUTTON(0)
WEND
ENDIF

IF BUTTON(0)==#Y THEN
COLOR 15,0
PRINT
PRINT "INSTRUCTION PROFILE ACTIVATED"
LADD=15
RRV=0
WHILE BUTTON(0)
WEND
ENDIF

IF BUTTON(0)==#X THEN
COLOR 15,0
PRINT
PRINT "MEMORY AND INSTRUCTION PROFILE ACTIVATED"
LADD=15
RRV=0
RMM%=3
WHILE BUTTON(0)
WEND
ENDIF


'VIRTUAL COMPUTER STARTS HERE
RESET
BGMSTOP 0,0.5
'IF !DEBUG% THEN
'DRAW THE BORDER RECTANGLE
DISPLAY 0
GBOX 71,23,328,216,RGB(173,71,255)
DISPLAY 1
GBOX 31,23,288,216,RGB(173,71,255)
'ENDIF
'INITIALISE TRANSPARENT SCREEN
COLOR 15,0
CLS
DISPLAY 0
COLOR 15,0
CLS
REFRESH'INITIAL REFRESH
DBM=0
STIME=MILLISEC'STORE INITIAL MILLISEC
ST$=STR$((CENDT%-CSTARTT%)/1000) 'FORMAT AS SECONDS

@MAIN
IP%=REG%[15]
CI%=RAM%[IP%]

IF CI%<=104 THEN
ARC%=AC%[CI%]
FOR ARGC%=1 TO ARC%
ARG%[ARGC%-1]=RAM%[(IP%+ARGC%) AND &HFFFF]
NEXT
ELSE
ARC%=0
ENDIF

IF DEBUG% THEN DEBUG_MODE
REG%[15]=(IP%+ARC%+1) AND &HFFFF
'**NOISYMODE
'IF CI%<256 THEN BEEP 49,(CI%-45)*100
'IF CI%>=256 THEN BEEP 2,((CI% MOD 16)-36)*100

IF CI%<256 THEN
ON CI% GOSUB @OP0,@OP1,@OP2,@OP3,@OP4,@OP5,@OP6,@OP7,@OP8,@OP9,@OP10,@OP11,@OP12,@OP13,@OP14,@OP15,@OP16,@OP17,@OP18,@OP19,@OP20,@OP21,@OP22,@OP23,@OP24,@OP25,@OP26,@OP27,@OP28,@OP29,@OP30,@OP31,@OP32,@OP33,@OP34,@OP35,@OP36,@OP37,@OP38,@OP39,@OP40,@OP41,@OP42,@OP43,@OP44,@OP45,@OP46,@OP47,@OP48,@OP49,@OP50,@OP51,@OP52,@OP53,@OP54,@OP55,@OP56,@OP57,@OP58,@OP59,@OP60,@OP61,@OP62,@OP63,@OP64,@OP65,@OP66,@OP67,@OP68,@OP69,@OP70,@OP71,@OP72,@OP73,@OP74,@OP75,@OP76,@OP77,@OP78,@OP79,@OP80,@OP81,@OP82,@OP83,@OP84,@OP85,@OP86,@OP87,@OP88,@OP89,@OP90,@OP91,@OP92,@OP93,@OP94,@OP95,@OP96,@OP97,@OP98,@OP99,@OP100,@OP101,@OP102,@OP103,@OP104',@OP105,@OP106
ELSE GOSUB @DEX
ENDIF

INC CYCLES%

GOTO @MAIN
@HALT
FINISH=MILLISEC
SECONDS=(FINISH-STIME)/1000
DISPLAY 0
LOCATE 0,0
COLOR 15,3
PRINT CYCLES%;"c ";
PRINT SECONDS;"s ";
IF SECONDS>0 THEN PRINT CYCLES%/SECONDS;"HZ"
T=0
WHILE T==0
TOUCH OUT T,X,Y
IF BUTTON(0)==#X THEN STOP
WEND
'GOTO @RESET
IF DEBUG% THEN DEBUGMENU ELSE STOP






















































'SUBROUTINE AREA

DEF GETBTN()'WAITS FOR INPUT FROM THE USER
BTN=0
WHILE BUTTON(0)!=0
WEND
WHILE BUTTON(0)==0
WEND
WHILE BUTTON(0)!=0
BTN=BTN OR BUTTON(0)
WEND
RETURN BTN
END

DEF C0(CODE$)'RETURNS FIRST CHARACTER OF STRING
RETURN LEFT$(CODE$,1)
END

DEF FUNNY
FR=FLOOR(RND(7))*2+3
COLOR FR,0
IF LEN(INTT$)>0 THEN PRINT INTT$[RND(LEN(INTT$))]
END

DEF R(N)
RETURN N AND &HFFFF
END

DEF N(N)
RETURN N AND &HF
END

DEF WORD(W$,N) 'GET A WORD FROM A STRING
IX=0 'STRING INDEX
WX=0 'WORD INDEX
DIM WORD$[0] 'CREATE WORD STACK
IF W$=="" THEN RETURN "" 'NOTHING?

REPEAT
WHILE IX<LEN(W$)
IF W$[IX]!=" " AND W$[IX]!=CHR$(10) THEN BREAK
INC IX
WEND

'IX IS NOW FIRST CHARACTER OF WORD
'FIND END OF WORD
WX=IX

WHILE WX<LEN(W$)
IF W$[WX]==" " OR W$[IX]==CHR$(10) THEN BREAK
INC WX
WEND

'IX=FIRST CHR OF WORD, WX=FIRST SPACE AFTER WORD OR LAST CHR OF STRING, SO CORRECT FOR LATTER CASE
WORDLEN=WX-IX+(WX==LEN(W$))
NEWWORD$=MID$(W$,IX,WORDLEN)
PUSH WORD$,NEWWORD$
IX=WX 'LOOK FOR NEXT WORD
UNTIL NEWWORD$==""

IF N<LEN(WORD$) THEN RETURN WORD$[N] ELSE RETURN ""
END


'MODE
'0=SILENT MODE (DOES NOT DO ANYTHING ON SCREEN
'1=VERBOSE MODE (DISPLAYS COMPILATION PROGRESS)
'2=PREMIUM VERBOSE MODE (W/LABELS!)
'VERBOSE MODE HIGHLIGHTS AND DISPLAYS SYNTAX ERRORS

'FIRST%=1 WHEN USED BY THE PROGRAM, 0 WHEN USED WITHIN VC

'MAIN COMPILER,RETURNS UCSTART
DEF COMPILE(START,SLOT,MODE,FIRST%)
IF CI% THEN 
COLOR 15,0
DISPLAY 0
LOCATE 49,0
PRINT "";
ENDIF

MEMCUR=START 'MEMORY CURSOR
STCUR=0 'STRING CURSOR
CLLERASE

'NON-TRANSFORMING COMPILER

'STORES LABELS FIRST WHILE WRITING TO SOURCE CODE ARRAY IF OPCODE
'RESOLVES CONSTANT VALUES, FOR A CONSTANT MAY REFERENCE A LABEL
'COMPILES SOURCE CODE DIRECTLY INTO MACHINE CODE

IF MODE THEN
'XSCREEN 3
DISPLAY 0
COLOR 15,0
DISPLAY 1
COLOR 13,0
DISPLAY 0
ENDIF


'FIRST RESOLVE LABELS
'IF LABEL, WRITE CURRENT ADDRESS TO LABEL STACK
'IF ANYTHING ELSE, ADVANCE BYTE COUNT OR SET IT ACCORDING TO RELOCATIONS

BYTE=START 'CURRENT BYTE OF MEMORY
PRGEDIT 1
PRGEDIT 2
PRGEDIT SLOT
REPEAT
SORCE$=PRGGET$()
IF MODE THEN DISPLAY 0:PRINT SORCE$;
WORD=0 'LOOK FOR WORDS IN SOURCE

IF C0(SORCE$)!="$" THEN 'CHECK FOR STRINGS FIRST
REPEAT
SWORD$=WORD(SORCE$,WORD)

IF C0(SWORD$)=="'" THEN BREAK
IF C0(SWORD$)=="@" THEN WATCH=BYTE:WV=1:GOTO @WV_SKIP
IF C0(SWORD$)=="`" THEN WATCH2=BYTE:WV=1:GOTO @WV_SKIP


BYTE=LBLGEN(SWORD$,BYTE,MODE,START)
@WV_SKIP

INC WORD
UNTIL SWORD$==""
ELSE INC BYTE,LEN(SORCE$)-2
ENDIF

UNTIL SORCE$==""


'PRINT GETBTN()


IF FIRST% THEN
DISPLAY 0
PRINT "."
PRINT
FUNNY
PRINT
IF CNUM THEN COLOR 15,2 ELSE COLOR 15,8
PRINT LEN(CLL$);" LOCAL, ";LEN(CGL$);" GLOBAL LABELS";

ENDIF


'WRITE OUT TO MEMORY
'VERY SIMILAR PROCESS!

BYTE=START 'CURRENT BYTE OF MEMORY
MODEB=-1 'VERBOSE BYTECOUNT
PRGEDIT 1
PRGEDIT 2
PRGEDIT SLOT
REPEAT
SORCE$=PRGGET$()
IF MODE THEN
DISPLAY 0

IF MODEB!=BYTE THEN
IF CNUM THEN COLOR 15,3 ELSE COLOR 15,9
PRINT F16(BYTE);
COLOR 15,0
PRINT " ";
ELSE
IF CNUM THEN COLOR 15,2 ELSE COLOR 15,8
PRINT "    ";
COLOR 15,0
PRINT " ";
ENDIF
COLOR 15,0
PRINT SORCE$;

MODEB=BYTE
'VSYNC CDLY%
ENDIF
WORD=0 'LOOK FOR WORDS IN SOURCE

IF C0(SORCE$)!="$" THEN 'CHECK FOR STRINGS FIRST
SOURCE$[BYTE]=SORCE$
REPEAT
SWORD$=WORD(SORCE$,WORD)
IF C0(SWORD$)=="'" THEN BREAK
IF C0(SWORD$)!="@" AND C0(SWORD$)!="`" THEN BYTE=WRITE(SWORD$,BYTE,MODE,START) ELSE PRINT C0(SWORD$);

'PRINT TYPE
'PRINT GETBTN()
INC WORD
UNTIL SWORD$==""

ELSE FOR I=1 TO LEN(SORCE$)-2
SOURCE$[BYTE]=SORCE$
RAM%[BYTE+I-1]=ASC(SORCE$[I])
TYPE%[BYTE+I-1]=4
LASTN=ASC(SORCE$[I])
IF MODE THEN
DISPLAY 1
COLOR 4*2+1,0
PRINT SORCE$[I];
DISPLAY 0
ENDIF
NEXT

INC BYTE,LEN(SORCE$)-2

ENDIF

UNTIL SORCE$==""
'PRINT GETBTN()
IF CI% THEN
DISPLAY 0
COLOR 15,0
DISPLAY 0
LOCATE 49,0
PRINT " ";
ENDIF
RETURN BYTE
END


DEF CLLERASE
WHILE LEN(CLL$)>0
E$=POP(CLL$)
WEND
'DIM CLL$[0]
END

DEF LBLGEN(SRCWORD$,BYTE,MODE,START) 'SCAN SOURCE FOR LABELS AND ADVANCE BYTE COUNTER APPROPRIATELY
IF C0(SRCWORD$)=="+" THEN
INC BYTE,VAL(MID$(SRCWORD$,1,LEN(SRCWORD$)-1))
ELSEIF C0(SRCWORD$)=="*" THEN
BYTE=VAL(MID$(SRCWORD$,1,LEN(SRCWORD$)-1))+START
ELSEIF C0(SRCWORD$)=="/" THEN
BYTE=VAL(MID$(SRCWORD$,1,LEN(SRCWORD$)-1))
ELSEIF SRCWORD$=="" THEN
RETURN R(BYTE)
ELSEIF C0(SRCWORD$)==">" OR C0(SRCWORD$)==":" THEN NEWLBL SRCWORD$,MODE
ELSE INC BYTE 'SUBROUTINE DOES NOT HANDLE STRINGS
ENDIF
RETURN R(BYTE)
END

DEF LBLFIND(CODE$) 'REPLACE A REFERENCE
GL=C0(CODE$)==";"
INDEX=LSRC(CODE$)
IF INDEX==-1 THEN
DISPLAY 0
COLOR 3,1
PRINT "UNKNOWN LABEL ";CODE$
COLOR 15,3
STOP
ELSE
IF GL THEN RETURN VAL(LEFT$(CGL$[INDEX],5)) ELSE RETURN VAL(LEFT$(CLL$[INDEX],5))
ENDIF
END

DEF LSRC(CODE$) 'LABEL SEARCH
GL=C0(CODE$)==";"
IF CODE$[LEN(CODE$)-1]==CHR$(10) THEN CODE$=LEFT$(CODE$,LEN(CODE$)-1)
CODE$=MID$(CODE$,1,LEN(CODE$)-1)
LLOC=0
'PRINT CODE$';:;:;:
IF GL THEN
FOR I=0 TO LEN(CGL$)-1
IF MID$(CGL$[I],6,1000)==CODE$ THEN RETURN I

'IF INSTR(CHR$(10)+CGL$[I],CODE$)==7 THEN RETURN I
NEXT
RETURN -1
ENDIF
IF !GL THEN
FOR I=0 TO LEN(CLL$)-1
IF MID$(CLL$[I],6,1000)==CODE$ THEN RETURN I

'IF INSTR(CHR$(10)+CLL$[I],CODE$)==7 THEN RETURN I
NEXT
RETURN -1
ENDIF
END


DEF NEWLBL CODE$,MODE'CREATES A LABEL
GL=C0(CODE$)==":"
IF CODE$[LEN(CODE$)-1]==CHR$(10) THEN CODE$=LEFT$(CODE$,LEN(CODE$)-1)
'PRINT CODE$
LNAME$=MID$(CODE$,1,LEN(CODE$)-1)
ENTRY$=STR$(BYTE,5)+CHR$(10)+LNAME$
IF GL THEN
PUSH CGL$,ENTRY$
LABEL$[BYTE,1]="G"'GLOBAL LABEL
ELSE PUSH CLL$,ENTRY$
LABEL$[BYTE,1]="L"'LOCAL LABEL
ENDIF
LABEL$[BYTE,0]=LNAME$
LABEL$[BYTE,2]=STR$(CNUM)'COMPILATION NUMBER
IF MODE THEN
DISPLAY 1
IF GL THEN COLOR 15,8 ELSE COLOR 15,2
PRINT HEX$(BYTE,4);"-";CNUM;" ";LNAME$
DISPLAY 0
VSYNC LDLY%
ENDIF
END


'WRITE TO VIRTUAL MEMORY, FINALISING COMPILATION PROCESS
DEF WRITE(SRCWORD$,BYTE,MODE,START)
IF C0(SRCWORD$)=="+" THEN
INC BYTE,VAL(MID$(SRCWORD$,1,LEN(SRCWORD$)-1))
ELSEIF C0(SRCWORD$)=="*" THEN
BYTE=VAL(MID$(SRCWORD$,1,LEN(SRCWORD$)-1))+START
ELSEIF C0(SRCWORD$)=="/" THEN
BYTE=VAL(MID$(SRCWORD$,1,LEN(SRCWORD$)-1))
ELSEIF SRCWORD$=="" OR C0(SRCWORD$)==">" OR C0(SRCWORD$)==":" THEN
RETURN R(BYTE)
ELSE 
LASTN=CWORD(SRCWORD$,BYTE,MODE) 'COMPILE A SINGLE WORD
INC BYTE 'SUBROUTINE DOES NOT HANDLE STRINGS
ENDIF
RETURN R(BYTE)
END


DEF CWORD(SRCWORD$,BYTE,MODE)
'HANDLE PREFIXES FIRST
DAT=-1
C0$=C0(SRCWORD$)
IF C0$=="<" OR C0$==";" THEN DAT=LBLFIND(SRCWORD$):TYPE=6
IF C0$=="=" THEN DAT=LASTN:TYPE=7
IF C0$=="!" THEN DAT=ASC(SRCWORD$[1]):TYPE=1
IF C0$=="%" THEN DAT=&H90:TYPE=2
'REMAINING POSSIBILITIES:
'SOME KIND OF NUMBER
'AN INSTRUCTION
IF C0$=="." THEN ONCODE (RIGHT$(SRCWORD$,LEN(SRCWORD$)-1)) OUT GOT$,TYPE:DAT=VAL(GOT$)+&H10
IF C0$=="," THEN ONCODE (RIGHT$(SRCWORD$,LEN(SRCWORD$)-1)) OUT GOT$,TYPE:DAT=VAL(GOT$)+&H20
IF C0$=="?" THEN ONCODE (RIGHT$(SRCWORD$,LEN(SRCWORD$)-1)) OUT GOT$,TYPE:DAT=VAL(GOT$)+&H30
IF C0$=="(" THEN ONCODE (RIGHT$(SRCWORD$,LEN(SRCWORD$)-1)) OUT GOT$,TYPE:DAT=VAL(GOT$)+&H40
IF C0$==")" THEN ONCODE (RIGHT$(SRCWORD$,LEN(SRCWORD$)-1)) OUT GOT$,TYPE:DAT=VAL(GOT$)+&H50
IF C0$=="{" THEN ONCODE (RIGHT$(SRCWORD$,LEN(SRCWORD$)-1)) OUT GOT$,TYPE:DAT=VAL(GOT$)+&H60
IF C0$=="}" THEN ONCODE (RIGHT$(SRCWORD$,LEN(SRCWORD$)-1)) OUT GOT$,TYPE:DAT=VAL(GOT$)+&H70
IF C0$=="|" THEN ONCODE (RIGHT$(SRCWORD$,LEN(SRCWORD$)-1)) OUT GOT$,TYPE:DAT=VAL(GOT$)+&H80
IF C0$=="_" THEN ONCODE (SRCWORD$) OUT GOT$,TYPE:DAT=ULINE(GOT$)


IF DAT==-1 THEN ONCODE SRCWORD$ OUT GOT$,TYPE:DAT=VAL(GOT$)
RAM%[BYTE]=R(DAT)
TYPE%[BYTE]=TYPE
'PRINT TYPE%[BYTE]
IF MODE THEN
DISPLAY 1
IF LABEL$[BYTE,0]!="" AND MODE==2 THEN
IF LABEL$[BYTE,1]=="G" THEN COLOR 15,8 ELSE COLOR 15,2
PRINT
PRINT LABEL$[BYTE,0];
COLOR 15,1
PRINT " ";
ENDIF

COLOR TYPE*2+1,0
PRINT CHR$(DAT);
VSYNC CDLY%
DISPLAY 0
ENDIF
RETURN DAT
END



DEF ONCODE CODE$ OUT RETURN$, TYPE'CONVERT OPCODES TO NUMBERS
RETURN$=""
'IF LEN(CODE$)<=1 THEN
'RETURN$=CODE$:TYPE=2
'ELSEIF
IF INSTR("_-0123456789&",C0(CODE$))>=0 THEN
RETURN$=""+CODE$:TYPE=2
ELSEIF INSTR("#",C0(CODE$))>=0 THEN RETURN$=""+STR$(BTI(CODE$)):TYPE=2
ELSE RETURN$=""+STR$(GETOPCODE(LEFT$(CODE$,LEN(CODE$)))):TYPE=3
ENDIF
RETURN
END

'CONVERT UL STRINGS TO BINARY NUMBERS

DEF ULINE(CODE$)
RES=0 'RESULT

FOR I=0 TO LEN(CODE$)-1
IF INSTR("0123456789ABCDEF",CODE$[I])>=0 THEN RES=RES OR 1<<VAL("&H"+CODE$[I])
NEXT

RETURN RES
END


DEF BTI(B$) 'BUTTON STRING TO INTEGER
IF B$=="#UP" THEN RETURN 1
IF B$=="#DOWN" THEN RETURN 2
IF B$=="#LEFT" THEN RETURN 4
IF B$=="#RIGHT" THEN RETURN 8
IF B$=="#A" THEN RETURN 16
IF B$=="#B" THEN RETURN 32
IF B$=="#X" THEN RETURN 64
IF B$=="#Y" THEN RETURN 128
IF B$=="#L" THEN RETURN 256
IF B$=="#R" THEN RETURN 512
IF B$=="#ZR" THEN RETURN 2048
IF B$=="#ZL" THEN RETURN 4096

IF B$=="#UP"+CHR$(10) THEN RETURN 1
IF B$=="#DOWN"+CHR$(10) THEN RETURN 2
IF B$=="#LEFT"+CHR$(10) THEN RETURN 4
IF B$=="#RIGHT"+CHR$(10) THEN RETURN 8
IF B$=="#A"+CHR$(10) THEN RETURN 16
IF B$=="#B"+CHR$(10) THEN RETURN 32
IF B$=="#X"+CHR$(10) THEN RETURN 64
IF B$=="#Y"+CHR$(10) THEN RETURN 128
IF B$=="#L"+CHR$(10) THEN RETURN 256
IF B$=="#R"+CHR$(10) THEN RETURN 512
IF B$=="#ZR"+CHR$(10) THEN RETURN 2048
IF B$=="#ZL"+CHR$(10) THEN RETURN 4096
END

DEF GETOPCODE(OPCODE$)'CONVERT INSTRUCTION TO NUMBER
IF OPCODE$[LEN(OPCODE$)-1]==CHR$(10) THEN OPCODE$=LEFT$(OPCODE$,LEN(OPCODE$)-1)
OPCODE$="."+OPCODE$+"*"
'FFFF INDICATES AN INVALID INSTRUCTION ERROR
POSITION=INSTR(IS$,OPCODE$)-3
IF POSITION>=0 THEN
OPCODE=VAL(MID$(IS$,POSITION,3)) ELSE
RETURN$=CODE$
COLOR 3,1
PRINT 
PRINT "INVALID INSTRUCTION:";
COLOR 15,3
PRINT RIGHT$(LEFT$(OPCODE$,LEN(OPCODE$)-1),LEN(OPCODE$)-2)
BGMSTOP
STOP
ENDIF
RETURN OPCODE
END






























'VC RUNNING SUBROUTINES
DEF REFRESH
DRAW 9,3,40,26,0,REG%[13]
DRAW 4,3,35,26,1,REG%[14]
IF DEBUG% THEN DEBUGINFO
END

DEF DRAW X1,Y1,X2,Y2,S,ADDR
IF DEBUG% THEN
DISPLAY S
ADDRESS=REG%[13+S]
FOR Y=Y1 TO Y2
FOR X=X1 TO X2
CHAR=RAM%[R(ADDR)]
LOCATE X,Y
DBSETCOLOUR ADDR
PRINT CHR$(CHAR);
INC ADDR
NEXT
NEXT
ELSE
DISPLAY S
ADDRESS=REG%[13+S]
COLOR 15,0
FOR Y=Y1 TO Y2
FOR X=X1 TO X2
CHAR=RAM%[R(ADDR)]
IF CHKCHR(X,Y)!=CHAR THEN
LOCATE X,Y
PRINT CHR$(CHAR);
ENDIF
INC ADDR
NEXT
NEXT
ENDIF
END

DEF DBSETCOLOUR ADDRESS
ADDRESS=R(ADDRESS)
COLOR TYPE%[ADDRESS]*2+1,1
IF TYPE%[ADDRESS]==0 THEN COLOR 14,1'::::

'FOR I=0 TO 3
'IF ADR%[I]==ADDRESS THEN IF RW%[I]==1 THEN RED=1 ELSEIF RW%[I]==2 THEN CYAN=1
'NEXT

IF ADR%[0]==ADDRESS THEN IF RW%[0]==1 THEN RED=1 ELSEIF RW%[0]==2 THEN CYAN=1

IF ADR%[1]==ADDRESS THEN IF RW%[1]==1 THEN RED=1 ELSEIF RW%[1]==2 THEN CYAN=1

IF ADR%[2]==ADDRESS THEN IF RW%[2]==1 THEN RED=1 ELSEIF RW%[2]==2 THEN CYAN=1

IF ADR%[3]==ADDRESS THEN IF RW%[3]==1 THEN RED=1 ELSEIF RW%[3]==2 THEN CYAN=1


IF RED THEN COLOR 3,2
IF CYAN THEN COLOR 13,12
IF RED AND CYAN THEN COLOR 4,5
IF REG%[11]==ADDRESS THEN COLOR 8,9
IF REG%[12]==ADDRESS THEN COLOR 10,11
IF REG%[15]==ADDRESS THEN COLOR 6,7:RETURN

IF GRAYMODE% AND LEN(SSTACK%)>0 THEN
FOR I=LEN(SSTACK%)-1 TO 0 STEP -1
IF SSTACK%[I]==ADDRESS THEN COLOR 14,15:BREAK
IF DSTACK%[I]==ADDRESS THEN COLOR 1,14:BREAK
NEXT
ENDIF


END

DEF DEBUG_MODE 'HANDLES ALL DEBUG MODE FEATURES
IF RFM%==1 THEN REFRESH
IF RFM%==2 THEN IF (CI%>=10 AND CI%<=21) OR (CI%>=90 AND CI%<=91) THEN REFRESH
IF RFM%==3 THEN IF CI%==85 OR CI%==86 OR CI%==87 OR CI%==88 OR CI%==89 OR CI%>255 THEN REFRESH
IF RFM%==4 THEN IF CI%==85 OR CI%==88 OR CI%>255 THEN REFRESH
IF RFM%==5 THEN IF CI%==86 OR CI%==87 OR CI%==89 THEN REFRESH

IF RFM%==6 THEN IF WFRESH% AND ((WRITEA>=REG%[13] AND (WRITEA<(REG%[13]+&H300))) OR (WRITEA>=REG%[14] AND (WRITEA<(REG%[14]+&H300)))) THEN REFRESH:WFRESH%=0


IF BP%[REG%[15]]==1 THEN PAUSE=1:DEBUGMENU
IF BP%[REG%[15]]==2 THEN REFRESH
STICK OUT XL,YL
STICKEX OUT XR,YR
IF (XR+YR)!=0 THEN DEBUGMENU
IF YL>STYT THEN DEBUGMENU
IF XL>DBT AND PAUSE==0 THEN
REPEAT
STICK OUT XL,YL
UNTIL XL==0
PAUSE=1
ENDIF
IF XL<-DBT AND PAUSE==1 THEN
REPEAT
STICK OUT XL,YL
UNTIL XL==0
PAUSE=0
ENDIF

IF PAUSE==1 THEN
REFRESH
WHILE 1
STICKEX OUT XR,YR
IF (XR+YR)!=0 THEN DEBUGMENU
IF YL>STYT THEN DEBUGMENU
IF DEBUG%==0 THEN BREAK
STICK OUT XL,YL
IF XL>DBT THEN
REPEAT
STICK OUT XL,YL
UNTIL XL==0
BREAK
ENDIF
IF XL<-DBT THEN
PAUSE=0
REPEAT
STICK OUT XL,YL
UNTIL XL==0
BREAK
ENDIF
WEND
ENDIF
END

DEF DMGETNUM(H$,N)
RESET2
DISPLAY 0
COLOR 15,1
PRINT H$
PRINT
COLOR 3,1
PRINT "HEX:";HEX$(N,4)
COLOR 7,1
PRINT "DEC:";FORMAT$("%05D",N)
COLOR 5,1
PRINT "BIN:";BIN$(N,16)
COLOR 13,1
PRINT "CHR:";CHR$(N)
PRINT
COLOR 15,1
PRINT "NEW VALUE:";
COLOR 13,1
INPUT "",N
RESET
XSCREEN 3
N=R(N)
RETURN N
END

DEF DEBUGMENU
GRAYT%=GRAYMODE%
GRAYMODE%=0
DBM=1
WHILE TRUE
COLOR 15,0
CLS
REFRESH
DISPLAY 0
LOCATE 9,28
COLOR 15,1
PRINT "STATEXTRA";
IF BP%[REG%[15]]==1 THEN COLOR 15,1 ELSEIF BP%[REG%[15]]==2 THEN COLOR 13,1 ELSE COLOR 14,1
PRINT "BKPT";
COLOR 15,1
PRINT "RPUMPU";
IF LEN(DSTACK%)!=0 THEN PRINT "SPU";
LOCATE 9,29
COLOR 15,1
PRINT "";
IF RFM%==0 THEN COLOR 14,1:PRINT "RF:OFF";
IF RFM%==1 THEN COLOR 15,1:PRINT "RF:ON";
IF RFM%==2 THEN COLOR 3,1:PRINT "RF:RW";
IF RFM%==3 THEN COLOR 13,1:PRINT "RF:[]";
IF RFM%==4 THEN COLOR 5,1:PRINT "RF:[";
IF RFM%==5 THEN COLOR 9,1:PRINT "RF:]";
IF RFM%==6 THEN COLOR 11,1:PRINT "RF:SC";
COLOR 15,1
PRINT "+";


LOCATE 50-LEN(ST$),0
COLOR 15,9
PRINT ST$;

BTN=GETBTN()
IF BTN==#X THEN BREAK
IF BTN==#LEFT THEN DMLEFT
IF BTN==#RIGHT THEN DMRIGHT
IF BTN==#A THEN DMEXTRA
IF BTN==#B THEN BP%[REG%[15]]=(BP%[REG%[15]]+1) MOD 3
IF BTN==#L THEN RPU
IF BTN==#R THEN MPU REG%[15]
IF BTN==#Y AND LEN(DSTACK%)>0 THEN SPU
IF BTN==#UP THEN MPUCONFIG
IF BTN==#DOWN THEN DMRFM%
WEND
COLOR 15,0
DMREFRESH
DBM=0
GRAYMODE%=GRAYT%
END

DEF DMREFRESH
DISPLAY 0
COLOR 15,0
CLS
DISPLAY 1
COLOR 15,0
CLS
REFRESH
DISPLAY 0
END

DEF DMEXTRA
WHILE TRUE
DMREFRESH
LOCATE 9,28
COLOR 15,1
PRINT "";
IF HEX THEN PRINT "HEX"; ELSE PRINT "DEC";
COLOR 15,1
PRINT "";
IF RWV THEN COLOR 15,1:PRINT "RWV:ON"; ELSE COLOR 14,1:PRINT "RWV:OFF";
COLOR 15,1
PRINT "";
IF AV THEN COLOR 15,1:PRINT "ARGV:ON"; ELSE COLOR 14,1:PRINT "ARGV:OFF";
COLOR 15,1
PRINT "";
IF WV THEN COLOR 15,1:PRINT "WV:ON"; ELSE COLOR 14,1:PRINT "WV:OFF";
COLOR 15,1
PRINT "+";
LOCATE 9,29
COLOR 15,1
PRINT "";
IF GRAYT% THEN COLOR 15,1:PRINT "GRAY:ON"; ELSE COLOR 14,1:PRINT "GRAY:OFF";



BTN=GETBTN()
IF BTN==#X THEN BREAK
IF BTN==#LEFT THEN HEX=1-HEX
IF BTN==#A THEN RWV=1-RWV
IF BTN==#B THEN AV=1-AV
IF BTN==#R THEN GRAYT%=1-GRAYT%
IF BTN==#Y THEN DMMORE
IF BTN==#UP THEN DMWATCH
WEND
END

DEF DMWATCH
WHILE TRUE
DMREFRESH
LOCATE 9,28
COLOR 15,1
PRINT "";
IF WV THEN COLOR 15,1:PRINT "ON"; ELSE COLOR 14,1:PRINT "OFF";
COLOR 15,1
PRINT "";F16(WATCH);
PRINT "";F16(WATCH2)


BTN=GETBTN()
IF BTN==#X THEN BREAK
IF BTN==#A THEN WV=1-WV
IF BTN==#B THEN WATCH=DMGETNUM("WATCH ADDRESS",WATCH)
IF BTN==#Y THEN WATCH2=DMGETNUM("WATCH ADDRESS 2",WATCH2)
WEND
END







DEF DMMORE
WHILE TRUE
DMREFRESH
LOCATE 9,28
COLOR 15,1
PRINT "";
IF INSV THEN COLOR 15,1:PRINT "INSV:ON"; ELSE COLOR 14,1:PRINT "INSV:OFF";
COLOR 15,1
PRINT "";
IF LAV THEN COLOR 15,1:PRINT "LV:ON"; ELSE COLOR 14,1:PRINT "LV:OFF";
BTN=GETBTN()
IF BTN==#X THEN BREAK
IF BTN==#A THEN INSV=1-INSV
IF BTN==#B THEN LAV=1-LAV
WEND
END






DEF DMRIGHT
WHILE TRUE
DMREFRESH
LOCATE 9,28
COLOR 15,1
PRINT "REGAUX";
IF RSVM THEN PRINT "STACK"; ELSE PRINT "DISPLAY";
BTN=GETBTN()
IF BTN==#X THEN BREAK
IF BTN==#A THEN DMRREG
IF BTN==#B THEN DMRAUX
IF BTN==#Y THEN RSVM=1-RSVM
WEND
END

DEF DMRREG
WHILE TRUE
DMREFRESH
LOCATE 9,28
COLOR 15,1
PRINT "";
IF RRV THEN COLOR 15,1:PRINT "ON"; ELSE COLOR 14,1:PRINT "OFF";
COLOR 15,1
PRINT "";
IF RPM THEN COLOR 15,1 ELSE COLOR 14,1
PRINT "PM:";RPM;
BTN=GETBTN()
IF BTN==#X THEN BREAK
IF BTN==#A THEN RRV=1-RRV
IF BTN==#B THEN RPM=DMGETNUM("RIGHT POINTER MODE",RPM)
WEND
END

DEF DMRAUX
WHILE TRUE
DMREFRESH
LOCATE 9,28
COLOR 15,1
PRINT "";
IF RSVAD THEN COLOR 15,1:PRINT "ON"; ELSE COLOR 14,1:PRINT "OFF";
COLOR 15,1
PRINT "";
IF RPD THEN COLOR 15,1 ELSE COLOR 14,1
PRINT "PD:";RPD;
COLOR 15,1
PRINT "";
PRINT "ADDR:";F16(RADD);
PRINT "";
PRINT "OFF:";F16(ROFF);
LOCATE 9,29
PRINT "";
PRINT "BASE:";F16(RBASE);
PRINT "";
IF RBR THEN COLOR 15,1 ELSE COLOR 14,1
PRINT "BR";
COLOR 15,1
PRINT "";
IF RMM%==0 THEN COLOR 14,1 ELSEIF RMM%==1 THEN COLOR 3,1 ELSEIF RMM%==2 THEN COLOR 13,1 ELSE COLOR 5,1
PRINT "MM";

BTN=GETBTN()
IF BTN==#X THEN BREAK
IF BTN==#A THEN RSVAD=1-RSVAD
IF BTN==#B THEN RPD=DMGETNUM("RIGHT POINTER DEPTH",RPD)
IF BTN==#LEFT THEN RADD=DMGETNUM("RIGHT ADDRESS",RADD)
IF BTN==#RIGHT THEN ROFF=DMGETNUM("LEFT OFFSET",ROFF)
IF BTN==#UP THEN RBR=1-RBR

IF BTN==#L THEN RADD=R(RADD-1)
IF BTN==#R THEN RADD=R(RADD+1)
IF BTN==ZL% THEN ROFF=R(ROFF-1)
IF BTN==ZR% THEN ROFF=R(ROFF+1)
IF BTN==#Y THEN RBASE=DMGETNUM("STACK BASE",RBASE)
IF BTN==#DOWN THEN DMRMM
WEND
END




DEF DMLEFT
WHILE TRUE
DMREFRESH
LOCATE 9,28
COLOR 15,1
PRINT "REGAUX";
IF LSVM THEN PRINT "STACK"; ELSE PRINT "DISPLAY";

BTN=GETBTN()
IF BTN==#X THEN BREAK
IF BTN==#A THEN DMLREG
IF BTN==#B THEN DMLAUX
IF BTN==#Y THEN LSVM=1-LSVM
WEND
END

DEF DMLREG
WHILE TRUE
DMREFRESH
LOCATE 9,28
COLOR 15,1
PRINT "";
IF LRV THEN COLOR 15,1:PRINT "ON"; ELSE COLOR 14,1:PRINT "OFF";
COLOR 15,1
PRINT "";
IF LPM THEN COLOR 15,1 ELSE COLOR 14,1
PRINT "PM:";LPM;
BTN=GETBTN()
IF BTN==#X THEN BREAK
IF BTN==#A THEN LRV=1-LRV
IF BTN==#B THEN LPM=DMGETNUM("LEFT POINTER MODE",LPM)
WEND
END

DEF DMLAUX
WHILE TRUE
DMREFRESH
LOCATE 9,28
COLOR 15,1
PRINT "";
IF LSVAD THEN COLOR 15,1:PRINT "ON"; ELSE COLOR 14,1:PRINT "OFF";
COLOR 15,1
PRINT "";
IF LPD THEN COLOR 15,1 ELSE COLOR 14,1
PRINT "PD:";LPD;
COLOR 15,1
PRINT "";
PRINT "ADDR:";F16(LADD);
PRINT "";
PRINT "OFF:";F16(LOFF);
LOCATE 9,29
PRINT "";
PRINT "BASE:";F16(LBASE);
PRINT "";
IF LBR THEN COLOR 15,1 ELSE COLOR 14,1
PRINT "BR";
COLOR 15,1
PRINT "";
IF LMM%==0 THEN COLOR 14,1 ELSEIF LMM%==1 THEN COLOR 3,1 ELSEIF LMM%==2 THEN COLOR 13,1 ELSE COLOR 5,1
PRINT "MM";

BTN=GETBTN()
IF BTN==#X THEN BREAK
IF BTN==#A THEN LSVAD=1-LSVAD
IF BTN==#B THEN LPD=DMGETNUM("LEFT POINTER DEPTH",LPD)
IF BTN==#LEFT THEN LADD=DMGETNUM("LEFT ADDRESS",LADD)
IF BTN==#RIGHT THEN LOFF=DMGETNUM("LEFT OFFSET",LOFF)
IF BTN==#UP THEN LBR=1-LBR

IF BTN==#L THEN LADD=R(LADD-1)
IF BTN==#R THEN LADD=R(LADD+1)
IF BTN==ZL% THEN LOFF=R(LOFF-1)
IF BTN==ZR% THEN LOFF=R(LOFF+1)
IF BTN==#Y THEN LBASE=DMGETNUM("STACK BASE",LBASE)
IF BTN==#DOWN THEN DMLMM
WEND
END

DEF DMLMM
WHILE TRUE
DMREFRESH
LOCATE 9,28
COLOR 15,1

PRINT "";
IF LMM%==0 THEN COLOR 15,1 ELSE COLOR 14,1
PRINT "OFF";
COLOR 15,1
PRINT "";
IF LMM%==1 THEN COLOR 3,1 ELSE COLOR 14,1
PRINT "READ";
COLOR 15,1
PRINT "";
IF LMM%==2 THEN COLOR 13,1 ELSE COLOR 14,1
PRINT "WRITE";
COLOR 15,1
PRINT "";
IF LMM%==3 THEN COLOR 5,1 ELSE COLOR 14,1
PRINT "BOTH";

BTN=GETBTN()
IF BTN==#X THEN BREAK
IF BTN==#A THEN LMM%=0
IF BTN==#B THEN LMM%=1
IF BTN==#Y THEN LMM%=2
IF BTN==#UP THEN LMM%=3
WEND
END



DEF DMRMM
WHILE TRUE
DMREFRESH
LOCATE 9,28
COLOR 15,1

PRINT "";
IF RMM%==0 THEN COLOR 15,1 ELSE COLOR 14,1
PRINT "OFF";
COLOR 15,1
PRINT "";
IF RMM%==1 THEN COLOR 3,1 ELSE COLOR 14,1
PRINT "READ";
COLOR 15,1
PRINT "";
IF RMM%==2 THEN COLOR 13,1 ELSE COLOR 14,1
PRINT "WRITE";
COLOR 15,1
PRINT "";
IF RMM%==3 THEN COLOR 5,1 ELSE COLOR 14,1
PRINT "BOTH";

BTN=GETBTN()
IF BTN==#X THEN BREAK
IF BTN==#A THEN RMM%=0
IF BTN==#B THEN RMM%=1
IF BTN==#Y THEN RMM%=2
IF BTN==#UP THEN RMM%=3
WEND
END





DEF DMRFM%
WHILE TRUE
DMREFRESH
LOCATE 9,28
COLOR 15,1
PRINT "";
IF RFM%==1 THEN COLOR 15,1 ELSE COLOR 14,1
PRINT "ON";
COLOR 15,1
PRINT "";
IF RFM%==0 THEN COLOR 15,1 ELSE COLOR 14,1
PRINT "OFF";
COLOR 15,1
PRINT "";
IF RFM%==2 THEN COLOR 3,1 ELSE COLOR 14,1
PRINT "RW";
COLOR 15,1
PRINT "";
IF RFM%==3 THEN COLOR 13,1 ELSE COLOR 14,1
PRINT "[]";
COLOR 15,1
PRINT "";
IF RFM%==4 THEN COLOR 5,1 ELSE COLOR 14,1
PRINT "[";
COLOR 15,1
PRINT "";
IF RFM%==5 THEN COLOR 9,1 ELSE COLOR 14,1
PRINT "]";
COLOR 15,1
PRINT "";
IF RFM%==6 THEN COLOR 11,1 ELSE COLOR 14,1
PRINT "SC";


BTN=GETBTN()
IF BTN==#X THEN BREAK
IF BTN==#A THEN RFM%=1
IF BTN==#B THEN RFM%=0
IF BTN==#Y THEN RFM%=2
IF BTN==#UP THEN RFM%=3
IF BTN==#LEFT THEN RFM%=4
IF BTN==#RIGHT THEN RFM%=5
IF BTN==#R THEN RFM%=6
WEND
END




DEF INFIND(N)'FIND INSTRUCTION FROM OPCODE
IF N<256 THEN
POSITION1=INSTR(IS$," "+FORMAT$("%03D",N)+".")+5
POSITION2=INSTR(POSITION1,IS$,"*")
RET$=MID$(IS$,POSITION1,POSITION2-POSITION1)
ELSE RET$=LVIEW2(N)
ENDIF
RETURN RET$
END


DEF F16(N)'FORMAT A 16-BIT NUMBER
IF HEX==0 THEN RETURN FORMAT$("%05D",N) ELSE RETURN FORMAT$("%04X",N)
END

DEF FD16(N)'FORMAT A 16-BIT NUMBER (PRETTY!)
IF HEX==0 THEN RETURN FORMAT$("%D",N) ELSE RETURN FORMAT$("%X",N)
END

DEF F4(N)'FORMAT A 4-BIT NUMBER
RETURN C0(FORMAT$("%01X",N))
END

DEF D1(INDEX,TY)'DISASSEMBLE 1 WORD
IF TY==3 THEN RETURN INFIND(RAM%[INDEX])
IF TY==0 OR TY==2 THEN RETURN FD16(RAM%[INDEX])
IF TY==1 THEN RETURN "!"+CHR$(RAM%[INDEX])
IF TY==4 THEN RETURN "$"+CHR$(RAM%[INDEX])
IF TY==5 THEN RETURN ""+CHR$(RAM%[INDEX])
IF TY==6 THEN RETURN LABELD1(INDEX)
IF TY==7 THEN RETURN "="
END

DEF LABELD1(INDEX)
IF LVIEW(RAM%[INDEX]) THEN RETURN$=LVIEW2(RAM%[INDEX])
IF LVIEW(RAM%[INDEX])=="" THEN RETURN$="N/A:"+F16(RAM%[INDEX])
RETURN RETURN$
END

DEF DISASSEMBLE(INDEX,IV)'DISASSEMBLE WHOLE INSTRUCTIONS
IF TYPE%[INDEX]==3 OR IV THEN
ARGC=ARGFIND(RAM%[INDEX])
ELSE ARGC=0
ENDIF
RETURN$=""
FOR I=0 TO ARGC
IF IV AND I==0 THEN TY=3 ELSE TY=TYPE%[R(INDEX+I)]
RETURN$=RETURN$+D1(R(INDEX+I),TY)+" "
NEXT
RETURN RETURN$
END

DEF STACKVIEW X,Y,N,I,LE
DISPLAY 0
FOR L=1 TO N
B$=""
C2=1
C1=(TYPE%[R(I+(L-1))]*2)
CI2=C2
CI1=C1
IF LE THEN
IF LBASE==R(I+(L-1)) THEN CI2=3:CI1=15:B$=""
ELSE 
IF RBASE==R(I+(L-1)) THEN CI2=3:CI1=15:B$=""
ENDIF

IF C1==0 THEN C2=15:C1=1
PDATA RAM%[R(I+(L-1))],B$,X,Y+(L-1),CI1,CI2,C1,C2
NEXT
END

DEF AUXDRAW X1,Y1,X2,Y2,S,ADDR
DRAW X1,Y1,X2,Y2,S,ADDR
PDATA ADDR,"",X1,Y2+1,13,1,13,1
PDATA RAM%[ADDR],"",X1,Y2+2,15,1,15,1
END



DEF ARGFIND(N)'GET ARGUMENT COUNT
POSITION1=INSTR(IS$," "+FORMAT$("%03D",N)+".")+4
POSITION2=INSTR(POSITION1,IS$,"*")
RETURN VAL(MID$(IS$,POSITION2+1,1))
END

DEF ARGFETCH N'POPULATE ARGUMENT ARRAY
'ARGC=AC%[N]'ARGUMENT COUNT
FOR I=1 TO N
ARG%[I-1]=RAM%[(IP%+I) AND &HFFFF]
NEXT
END

DEF DEBUGINFO'CALLS RELEVANT DEBUG DISPLAY ROUTINES
IF INSV THEN INSTRUCTIONVIEW
IF LAV THEN LABELVIEW
IF RWV THEN READWRITEVIEW
IF WV THEN WATCHVIEW
IF AV THEN ARGUMENTVIEW
IF LRV THEN REGISTERVIEW 0,2,LPM
IF RRV THEN REGISTERVIEW 42,2,RPM
IF LSVAD THEN LEFTEXTRA
IF RSVAD THEN RIGHTEXTRA
IF !DBM THEN VSYNC RFVSYNC
END

DEF PDATA N,B$,X,Y,FB,BB,FN,BN'PRINT DATA
N=R(N)
LOCATE X,Y
COLOR 15,1
PRINT CHR$(N);
LOCATE X+1,Y
COLOR 14,1
PRINT CHR$(RAM%[N]);
LOCATE X+2,Y
COLOR FB,BB
PRINT B$
LOCATE X+3,Y
COLOR FN,BN
PRINT F16(N);
END

DEF INSTRUCTIONVIEW
DISPLAY 0
LOCATE 0,0
COLOR 15,0
PRINT "                                                   "
LOCATE 0,0
COLOR 15,1
IF TYPE%[REG%[15]]!=3 THEN COLOR 3,0
IF TYPE%[REG%[15]]==6 THEN COLOR 15,9
IF SOURCE$[REG%[15]]!="" THEN SOURCEPRINT REG%[15],50 ELSE COLOR 15,3:TRUNCPRINT " "+DISASSEMBLE(REG%[15],1),50
LOCATE 0,1
PRINT 
END

DEF SOURCEPRINT ADDRESS,LENGTH
COLOR 15
GAP=INSTR(0,SOURCE$[ADDRESS]," '")
IF GAP==-1 THEN
TRUNCPRINT SOURCE$[ADDRESS],LENGTH ELSE
TRUNCPRINT LEFT$(SOURCE$[ADDRESS],GAP),LENGTH
COLOR 5,1
IF GAP<LENGTH THEN TRUNCPRINT RIGHT$(SOURCE$[ADDRESS],LEN(SOURCE$[ADDRESS])-GAP),LENGTH-GAP
ENDIF
END

DEF GETCODE(ADDRESS)
GAP=INSTR(0,SOURCE$[R(ADDRESS)]," '")

IF GAP==-1 THEN
RETURN SOURCE$[R(ADDRESS)] ELSE
RETURN LEFT$(SOURCE$[R(ADDRESS)],GAP)
ENDIF
END

DEF GETCOMMENT(ADDRESS)
GAP=INSTR(0,SOURCE$[R(ADDRESS)]," '")

IF GAP==-1 THEN
RETURN "" ELSE
RETURN RIGHT$(SOURCE$[R(ADDRESS)],LEN(SOURCE$[R(ADDRESS)])-GAP-1)
ENDIF
END

DEF DELTRAIL(ST$)
IF ST$=="" THEN RETURN ""
IF MID$(ST$,LEN(ST$)-1,1)==CHR$(10) THEN RETURN DELTRAIL(LEFT$(ST$,LEN(ST$)-1)) ELSE RETURN ST$
END



DEF ARGUMENTVIEW
DISPLAY 1
COLOR 15,0
LOCATE 4,27
PRINT "                                     "
'IF !DBM THEN 
PDATA CI%,"0",4,27,15,2,1,15
COLOR 15,1
PRINT " "+D1(REG%[15],TYPE%[REG%[15]])
'ENDIF
LOCATE 4,28
COLOR 15,0
PRINT "                                   "
'IF TYPE%[REG%[15]]!=3 THEN RETURN
FOR I=1 TO ARGFIND(CI%)
PDATA ARG%[I-1],STR$(I),(I-1)*8+4,28,15,3,15,9
NEXT
END

DEF READWRITEVIEW
'DISPLAY LAST 4 R/WS
DISPLAY 1
FOR I=0 TO 3
CC=(RW%[I]==1)*3+(RW%[I]==2)*13
IF INST%[I]!=INST%[3] THEN DEC CC
IF CC<0 THEN CC=14
PDATA INST%[I],"",I*10,0,CC,1,CC,1
PDATA ADR%[I],"",I*10,1,CC,1,CC,1
PDATA DTT%[I],"",I*10,2,CC,1,1,CC':@*:@*
NEXT
DISPLAY 0
LOCATE 0,29
COLOR 15,0
PRINT "                                                  ";
FOR I=0 TO 3
CC=(RW%[I]==1)*3+(RW%[I]==2)*13
IF INST%[I]!=INST%[3] THEN DEC CC
IF CC<0 THEN CC=14
LOCATE FLOOR((I*12.5)),29
COLOR CC,0
TRUNCPRINT LVIEW2(ADR%[I]),12
NEXT



END

DEF CLLLRLW
DIM LRA[0]
DIM LWA[0]
DIM LRD[0]
DIM LWD[0]
END


DEF WATCHVIEW
DISPLAY 0

LOCATE 9,27
COLOR 15,0
PRINT "                                "
PDATA WATCH,"",9,27,7,1,7,1
PDATA RAM%[WATCH],"",18,27,1,7,1,7
COLOR 7,1
TRUNCPRINT " "+LVIEW2(RAM%[WATCH]),16

LOCATE 9,28
COLOR 15,0
PRINT "                                "
PDATA WATCH2,"",9,28,7,1,7,1
PDATA RAM%[WATCH2],"",18,28,1,7,1,7
COLOR 7,1
TRUNCPRINT " "+LVIEW2(RAM%[WATCH2]),16

END

DEF LABELVIEW
IF LEN(LVIEW(REG%[15])) THEN LASTL=REG%[15]
DISPLAY 0
LOCATE 9,2
COLOR 15,0
PRINT "                                "
LOCATE 9,2
PRINT LVIEW2(LASTL)
LOCATE 9,1
COLOR 15,1
PRINT "                                "
IF LEN(DSTACK%)>0 THEN
LOCATE 9,1
COLOR 15,3
PRINT LEN(DSTACK%);
COLOR 13,1
PRINT LVIEW2(DSTACK%[LEN(DSTACK%)-1])
ENDIF
END

DEF RM(M)'READ MEMORY
ADDR%=R(M)
DAT%=RAM%[ADDR%]
IF !DEBUG% THEN RETURN DAT%
'PRINT "#####"
READA=ADDR%
H=SHIFT(ADR%)
H=SHIFT(DTT%)
H=SHIFT(RW%)
H=SHIFT(INST%)
PUSH ADR%,ADDR%
PUSH DTT%,DAT%
PUSH RW%,1
PUSH INST%,IP%
RETURN DAT%
END

DEF WM N,M'WRITE MEMORY
DAT%=N
ADDR%=R(M)
RAM%[ADDR%]=DAT%

'IF (M>=REG%[13] AND M<REG%[13]+&H300) OR (M>=REG%[14] AND M<REG%[14]+&H300) THEN REFRESH

IF !DEBUG% THEN RETURN
TYPE%[ADDR%]=0
'PRINT "#####"
WRITEA=ADDR%
WFRESH%=1

H=SHIFT(ADR%)
H=SHIFT(DTT%)
H=SHIFT(RW%)
H=SHIFT(INST%)
PUSH ADR%,ADDR%
PUSH DTT%,DAT%
PUSH RW%,2
PUSH INST%,IP%
END

DEF LT N,M'WRITE MEMORY, BUT FOR TEXT
DAT%=N
ADDR%=R(M)
RAM%[ADDR%]=DAT%
TYPE%[ADDR%]=5
END

DEF IIP N
REG%[15]=(REG%[15]+N) AND &HFFFF
END



DEF REGISTERVIEW X,Y,PM'DISPLAY REGISTERS
DISPLAY 0
FOR I=0 TO 15
C=3
C2=15
C3=15
IF I==11 THEN C=10
IF I==12 THEN C=11
IF I==13 THEN C=4
IF I==14 THEN C=5
IF I>14 THEN C=9
NUM=R(REG%[I])
FOR L=1 TO PM
C2=(TYPE%[NUM]*2)+1
IF C2==1 THEN C2=15
NUM=RAM%[NUM]
NEXT
IF LEN(RU%) THEN IF (RU%[LEN(RU%)-1] AND 1<<I) THEN SWAP C3,C ELSE DEC C2
PDATA NUM,F4(I),X,Y+I,C3,C,C2,1
NEXT
END


DEF LEFTEXTRA
IF !LRV THEN MINROW=2:STACKHEIGHT=27 ELSE MINROW=19:STACKHEIGHT=10

IF LSVAD THEN
POINTER=LADD
IF LPD AND !LBR THEN POINTER=REG%[N(LADD)]

IF !LMM% THEN
FOR L=2 TO LPD
POINTER=RAM%[POINTER]
NEXT
POINTER=R(POINTER+LOFF)
ELSEIF LMM%==1 THEN
POINTER=R(READA+LOFF)
ELSEIF LMM%==2 THEN
POINTER=R(WRITEA+LOFF)
ELSEIF LMM%==3 THEN
IF RW%[0]==1 THEN POINTER=R(READA+LOFF) ELSE POINTER=R(WRITEA+LOFF)
ENDIF

IF LSVM THEN STACKVIEW 0,MINROW,STACKHEIGHT,POINTER,1 ELSE AUXDRAW 0,MINROW,7,26,0,POINTER
ENDIF
END

DEF RIGHTEXTRA
IF !RRV THEN MINROW=1:STACKHEIGHT=28 ELSE MINROW=19:STACKHEIGHT=10

IF RSVAD THEN
POINTER=RADD
IF RPD AND !RBR THEN POINTER=REG%[N(RADD)]

IF !RMM% THEN
FOR L=2 TO RPD
POINTER=RAM%[POINTER]
NEXT
POINTER=R(POINTER+ROFF)
ELSEIF RMM%==1 THEN
POINTER=R(READA+ROFF)
ELSEIF RMM%==2 THEN
POINTER=R(WRITEA+ROFF)
ELSEIF RMM%==3 THEN
IF RW%[0]==1 THEN POINTER=R(READA+ROFF) ELSE POINTER=R(WRITEA+ROFF)
ENDIF

IF RSVM THEN STACKVIEW 42,MINROW,STACKHEIGHT,POINTER,0 ELSE AUXDRAW 42,MINROW,49,26,0,POINTER
ENDIF
END

DEF RESET
DISPLAY 0
COLOR 15,0
CLS
DISPLAY 1
COLOR 15,0
CLS
END

DEF RESET2
DISPLAY 0
COLOR 15,1
CLS
DISPLAY 1
COLOR 15,1
CLS
END



DEF RPU
CU%=0'RPU CURSOR
ATC%=0'AT CURSOR
WHILE 1
RESET2
DISPLAY 0
C=3
C2=15
FOR I=0 TO 15
IF I==11 THEN C=10
IF I==12 THEN C=11
IF I>12 THEN C=5
IF I>14 THEN C=9
NUM=R(REG%[I])
FOR L=1 TO MPD
C2=(TYPE%[NUM]*2)+1
IF C2==1 THEN C2=15
NUM=RAM%[NUM]
NEXT
IF I!=CU% THEN PDATA NUM,F4(I),0,I,15,C,C2,1 ELSE PDATA NUM,F4(I),0,I,C,15,1,C:ATC%=NUM
NEXT
DISPLAY 1
COLOR 13,1
PRINT F16(ATC%)
COLOR 15,1
PRINT
PRINT "SCROLL EDIT MPU CONFIG EXTRAS"
BTN=GETBTN()
IF BTN==#X THEN BREAK
IF BTN==#UP THEN CU%=N(CU%-1)
IF BTN==#DOWN THEN CU%=N(CU%+1)
IF BTN==#A THEN REG%[CU%]=DMGETNUM("REGISTER "+F4(CU%),REG%[CU%])
IF BTN==#Y THEN MPUCONFIG
IF BTN==#B THEN MPU REG%[CU%]
IF BTN==#L THEN MPUEXTRAS REG%[CU%]
WEND
RESET
END

DEF SPU
SEL=0
WIN=0
RESET
WHILE 1
DISPLAY 0
COLOR 15,1
CLS
LIM=LEN(DSTACK%)-1
IF LIM>(WIN+28) THEN LIM=(WIN+28)
FOR I=WIN TO LIM
COLOR 15,1
IF I==SEL THEN COLOR 15,3
PRINT F16(SSTACK%[I]);"";
PRINT F16(DSTACK%[I]);" ";

PRINT LVIEW2(SSTACK%[I]);"";
PRINT LVIEW2(DSTACK%[I])
NEXT

DISPLAY 1
CLS
LOCATE 0,0
COLOR 15,1
PRINT F16(SSTACK%[SEL]);":";
COLOR 13,1
PRINT DISASSEMBLE(SSTACK%[SEL],1)
COLOR 15,1
PRINT F16(DSTACK%[SEL]);":";
COLOR 13,1
PRINT DISASSEMBLE(DSTACK%[SEL],1)
COLOR 3,1
PRINT LVIEW2(SSTACK%[SEL])
COLOR 5,1
PRINT LVIEW2(DSTACK%[SEL])
COLOR 15,1
PRINT 
PRINT "SCROLL HOME END MPU D  MPU S"

BTN=GETBTN()
IF BTN==#X THEN BREAK
IF BTN==#UP THEN
DEC SEL
IF SEL==-1 THEN SEL=0
IF WIN>SEL THEN DEC WIN
ENDIF
IF BTN==#DOWN THEN
INC SEL
IF SEL>LEN(DSTACK%)-1 THEN DEC SEL
IF (WIN+28)<SEL THEN INC WIN
ENDIF
IF BTN==#A THEN MPU DSTACK%[SEL]
IF BTN==#B THEN MPU SSTACK%[SEL]
IF BTN==#L THEN SEL=0:WIN=0
IF BTN==#R THEN SEL=LEN(DSTACK%)-1:WIN=SEL


WEND
RESET
END






DEF BKPU
BKPULOOP=1
WHILE BKPULOOP
DIM BKSTACK%[0]'BREAKPOINT STACK
FOR I=0 TO LEN(BP%)-1
IF BP%[I] THEN PUSH BKSTACK%,I
NEXT
SEL=0
WIN=0
RESET
WHILE 1
'IF LEN(BKSTACK%)==0 THEN BREAK
DISPLAY 0
COLOR 15,1
CLS
LIM=LEN(BKSTACK%)-1
IF LIM>(WIN+28) THEN LIM=(WIN+28)
FOR I=WIN TO LIM
COLOR 15,1
IF I==SEL THEN COLOR 15,3
IF BP%[BKSTACK%[I]]==0 THEN COLOR 14,1
IF BP%[BKSTACK%[I]]==0 AND I==SEL THEN COLOR 14,2

PRINT F16(BKSTACK%[I]);
PRINT LVIEW2(BKSTACK%[I]);
IF BP%[BKSTACK%[I]]==2 THEN PRINT "";
PRINT
NEXT
IF LIM==-1 THEN COLOR 15,3:PRINT "NO BREAKPOINTS"

DISPLAY 1
COLOR 15,1
CLS
LOCATE 0,0
PRINT "                                     "
IF LEN(BKSTACK%)!=0 THEN
LOCATE 0,0
COLOR 15,1
PRINT F16(BKSTACK%[SEL]);":";
COLOR 13,1
PRINT DISASSEMBLE(BKSTACK%[SEL],1)
COLOR 15,1
PRINT 
ENDIF
PRINT "SCROLL EDIT NEW HOME END MPU RF"

BTN=GETBTN()
IF BTN==#X THEN BKPULOOP=0:BREAK
IF BTN==#UP THEN
DEC SEL
IF SEL==-1 THEN SEL=0
IF WIN>SEL THEN DEC WIN
ENDIF
IF BTN==#DOWN THEN
INC SEL
IF SEL>LEN(BKSTACK%)-1 THEN DEC SEL
IF (WIN+28)<SEL THEN INC WIN
ENDIF
IF BTN==#A THEN IF LEN(BKSTACK%) THEN MPU BKSTACK%[SEL]
IF BTN==#B THEN BREAK
IF BTN==#L THEN SEL=0:WIN=0
IF BTN==#R THEN IF LEN(BKSTACK%) THEN SEL=LEN(BKSTACK%)-1:WIN=SEL
IF BTN==#LEFT THEN IF LEN(BKSTACK%) THEN BP%[BKSTACK%[SEL]]=(BP%[(BKSTACK%[SEL])]+1) MOD 3
IF BTN==#RIGHT THEN BP%[DMGETNUM("NEW BREAKPOINT",0)]=1:BREAK

WEND
WEND
RESET
END








DEF LPU
BKPULOOP=1
WHILE BKPULOOP
DIM BKSTACK%[0]'LABEL STACK
FOR I=0 TO LEN(BP%)-1
IF LABEL$[I,0]!="" THEN PUSH BKSTACK%,I
NEXT
IF LEN(BKSTACK%)==0 THEN BREAK
SEL=0
WIN=0
RESET
WHILE 1
IF LEN(BKSTACK%)==0 THEN BREAK
DISPLAY 0
COLOR 15,1
CLS
LIM=LEN(BKSTACK%)-1
IF LIM>(WIN+28) THEN LIM=(WIN+28)
FOR I=WIN TO LIM
COLOR 15,1
IF I==SEL THEN COLOR 15,3
IF BP%[BKSTACK%[I]]==0 THEN COLOR 14,1
IF BP%[BKSTACK%[I]]==0 AND I==SEL THEN COLOR 14,2

PRINT F16(BKSTACK%[I]);
PRINT LVIEW2(BKSTACK%[I]);
IF BP%[BKSTACK%[I]]==2 THEN PRINT "";
PRINT
NEXT

DISPLAY 1
COLOR 15,1
CLS
LOCATE 0,0
PRINT "                                     "
IF LEN(BKSTACK%)!=0 THEN
LOCATE 0,0
COLOR 15,1
PRINT F16(BKSTACK%[SEL]);":";
COLOR 13,1
PRINT DISASSEMBLE(BKSTACK%[SEL],1)
COLOR 15,1
PRINT 
ENDIF
PRINT "SCROLL EDIT HOME END MPU RF"

BTN=GETBTN()
IF BTN==#X THEN BKPULOOP=0:BREAK
IF BTN==#UP THEN
DEC SEL
IF SEL==-1 THEN SEL=0
IF WIN>SEL THEN DEC WIN
ENDIF
IF BTN==#DOWN THEN
INC SEL
IF SEL>LEN(BKSTACK%)-1 THEN DEC SEL
IF (WIN+28)<SEL THEN INC WIN
ENDIF
IF BTN==#A THEN MPU BKSTACK%[SEL]
IF BTN==#B THEN BREAK
IF BTN==#L THEN SEL=0:WIN=0
IF BTN==#R THEN SEL=LEN(BKSTACK%)-1:WIN=SEL
IF BTN==#LEFT THEN BP%[BKSTACK%[SEL]]=(BP%[(BKSTACK%[SEL])]+1) MOD 3
'IF BTN==#RIGHT THEN BP%[DMGETNUM("NEW BREAKPOINT",0)]=1:BREAK

WEND
WEND
RESET
END












DEF MPU ADDR
RESET
WHILE 1
DISPLAY 0
COLOR 15,1
CLS
FOR Y=0 TO 28
CD=ADDR
NUM=Y+ADDR
FOR L=1 TO MPD
NUM=RAM%[R(NUM)]
NEXT
IF Y==0 THEN VIEWP=NUM
C2=(TYPE%[R(NUM)]*2)+1
IF C2==1 THEN C2=15
MPULINE NUM,Y,C2
IF Y==0 THEN CD=RAM%[NUM]
NEXT
COLOR 15,9
LOCATE 0,29
PRINT "EDIT SEARCH CONFIG BKPT FIND";
COLOR 15,3
PRINT " ZEXTRA ZGOTO";


DISPLAY 1
IF !ALTVIEW THEN
COLOR 15,0
CLS
LOCATE 0,0
PRINT "                                     "
LOCATE 0,0
COLOR 13,1
PRINT F16(ADDR);":";
COLOR 15,1
PRINT D1(ADDR,TYPE%[ADDR]);" ";
COLOR 15,3
PRINT DISASSEMBLE(ADDR,1)

DISPLAY 1
COLOR 15,0
DRAW 4,3,35,26,1,VIEWP
COLOR 15,1

ELSE COLOR 15,1
CLS
LOCATE 0,0
FOR Y=0 TO 28
IF CSRY>=28 THEN BREAK
IF LABEL$[R(ADDR+Y),0]!="" THEN
COLOR 15,1
IF CSRY!=0 THEN PRINT
IF CSRY>=28 THEN BREAK
COLOR 1,1
PRINT F16(R(ADDR+Y));
COLOR 15,1
PRINT " ";



C2=(TYPE%[R(ADDR+Y)]*2)+1
IF C2==1 THEN C2=15
COLOR 1,C2
PRINT LABEL$[R(ADDR+Y),0]
IF CSRY>=28 THEN BREAK
ENDIF


IF SOURCE$[R(ADDR+Y)]!="" THEN
COLOR 15,3
PRINT F16(R(ADDR+Y));
IF CSRY>=28 THEN BREAK
COLOR 15,1
PRINT " "+DELTRAIL(GETCODE(ADDR+Y))
IF CSRY>=28 THEN BREAK
COMM$=DELTRAIL(GETCOMMENT(ADDR+Y))
IF COMM$!="" THEN
COLOR 2,2
PRINT F16(R(ADDR+Y));
IF CSRY>=28 THEN BREAK

COLOR 5,1
PRINT COMM$
IF CSRY>=28 THEN BREAK
ENDIF

ENDIF
NEXT

ENDIF


BTN=GETBTN()
IF BTN==#X THEN BREAK
IF BTN==#UP THEN ADDR=R(ADDR-1)
IF BTN==#L THEN ADDR=R(ADDR-29)
IF BTN==#DOWN THEN ADDR=R(ADDR+1)
IF BTN==#R THEN ADDR=R(ADDR+29)
IF BTN==#A THEN RAM%[ADDR]=DMGETNUM("MEMORY ADDRESS "+F16(ADDR),RAM%[ADDR])
IF BTN==#B THEN ADDR=MPSEARCH(ADDR)
IF BTN==#Y THEN MPUCONFIG
IF BTN==#LEFT THEN BP%[ADDR]=(BP%[ADDR]+1) MOD 3
IF BTN==#RIGHT THEN ADDR=DMGETNUM("CURSOR POSITION ",ADDR)
IF BTN==#L+#R THEN ALTVIEW=1-ALTVIEW
IF BTN==ZL% THEN MPUEXTRAS ADDR
IF BTN==ZR% THEN ADDR=R(RAM%[ADDR])

WEND
RESET
END

DEF MPUEXTRAS ADR
WHILE 1
RESET2
DISPLAY 1
LOCATE 0,0
COLOR 15,1
PRINT " OPEN NESTED MPU"
PRINT " SET ";F16(ADR);" AS..."
PRINT " SET [";F16(ADR);"] OR ";F16(RAM%[ADR]);" AS"

BTN=GETBTN()
IF BTN==#A THEN NMPU ADR
IF BTN==#B THEN SETMENU ADR:BREAK
IF BTN==#Y THEN SETMENU2 ADR:BREAK
IF BTN==#X THEN BREAK
WEND
END

DEF SETMENU ADR
WHILE 1
RESET2
DISPLAY 1
LOCATE 0,0
COLOR 15,1
PRINT "SET ";F16(ADR);" AS"
PRINT
PRINT "LEFT RIGHT WATCH WATCH2"
COLOR 13,1
PRINT "ADDRESS BASE OFFSET"
BTN=GETBTN()

IF BTN==#LEFT+#A THEN LADD=ADR:BREAK
IF BTN==#RIGHT+#A THEN RADD=ADR:BREAK

IF BTN==#LEFT+#B THEN LBASE=ADR:BREAK
IF BTN==#RIGHT+#B THEN RBASE=ADR:BREAK

IF BTN==#LEFT+#Y THEN LOFF=ADR:BREAK
IF BTN==#RIGHT+#Y THEN ROFF=ADR:BREAK

IF BTN==#UP THEN WATCH=ADR:BREAK
IF BTN==#DOWN THEN WATCH2=ADR:BREAK
IF BTN==#X THEN BREAK

WEND

END

DEF SETMENU2 ADR
WHILE 1
RESET2
DISPLAY 1
LOCATE 0,0
COLOR 15,1
PRINT "SET [";F16(ADR);"] OR ";F16(RAM%[ADR]);" AS"
PRINT
PRINT "LEFT RIGHT WATCH"
COLOR 13,1
PRINT "ADDRESS BASE OFFSET"
BTN=GETBTN()
ADR=RAM%[ADR]

IF BTN==#LEFT+#A THEN LADD=ADR:BREAK
IF BTN==#RIGHT+#A THEN RADD=ADR:BREAK

IF BTN==#LEFT+#B THEN LBASE=ADR:BREAK
IF BTN==#RIGHT+#B THEN RBASE=ADR:BREAK

IF BTN==#LEFT+#Y THEN LOFF=ADR:BREAK
IF BTN==#RIGHT+#Y THEN ROFF=ADR:BREAK

IF BTN==#UP THEN WATCH=ADR:BREAK
IF BTN==#DOWN THEN WATCH2=ADR:BREAK
IF BTN==#X THEN BREAK

WEND

END






DEF NMPU ADR
WHILE 1
RESET2
DISPLAY 1
LOCATE 0,0
COLOR 13,1
PRINT "OPENING NESTED MPU AT ADDRESS ";F16(ADR)
PRINT
PRINT " CONTINUE"
BTN=GETBTN()
IF BTN==#A THEN MPU ADR:BREAK
IF BTN==#X THEN BREAK
WEND
END

DEF MPSEARCH(ADDR)
RESET2
XSCREEN 3
COLOR 15,1
PRINT "SEARCH  FROM TOP  FROM ";F16(ADDR);"  CUSTOM"
PRINT
BTN=GETBTN()
IF BTN==#A THEN
FROM=0
ELSEIF BTN==#B THEN
FROM=ADDR
ELSEIF BTN==#Y THEN
PRINT "SEARCH FROM:";
COLOR 13,1
INPUT "",FROM
COLOR 15,1
PRINT
ELSE RETURN ADDR
ENDIF

PRINT "FIND  SAME START  EXACT MATCH  ANYWHERE"
PRINT
BTN=GETBTN()
IF BTN==#A THEN
EX=1
ELSEIF BTN==#B THEN
EX=2
ELSEIF BTN==#Y THEN
EX=0
ELSE RETURN ADDR
ENDIF

PRINT " OF ALL COMPILATIONS  OF COMPILATION "
PRINT
BTN=GETBTN()
IF BTN==#A THEN
CN=-1
ELSEIF BTN==#B THEN
CN=-1
PRINT "COMPILATION:";
COLOR 13,1
INPUT "",CN
COLOR 15,1
PRINT
ELSE
RETURN ADDR
ENDIF
PRINT "SEARCH FOR LABEL"
IF CN>-1 THEN PRINT "OF COMPILATION ";CN
IF FROM THEN PRINT "FROM ";F16(ADDR) 

IF EX==2 THEN PRINT "MATCHING EXACTLY" ELSEIF EX==1 THEN PRINT "MATCHING START CHARACTERS ONLY" ELSE PRINT "MATCHING ANYWHERE"

PRINT
COLOR 13,1
INPUT "",SRC$
ADDR=FINDLABEL(SRC$,ADDR,FROM,CN,EX)
RETURN ADDR
RESET
END

DEF FINDLABEL(L$,ADDR,START,C,EX)
I=START
REPEAT
IF LVIEW(I)!="" THEN

IF EX==1 THEN
IF INSTR(LVIEW(I),L$)==0 AND (C==-1 OR VAL(LABEL$[I,2])==C) THEN ADDR=I:BREAK
ENDIF

IF EX==2 THEN
IF LVIEW(I)==L$ AND (C==-1 OR VAL(LABEL$[I,2])==C) THEN ADDR=I:BREAK
ENDIF

IF EX==0 THEN
IF INSTR(LVIEW(I),L$)>-1 AND (C==-1 OR VAL(LABEL$[I,2])==C) THEN ADDR=I:BREAK
ENDIF
ENDIF



INC I
UNTIL I==65536
RETURN ADDR
END





DEF MPULINE ADDR,Y,C
ADDR=R(ADDR)
DAT=RAM%[ADDR]
TY=TYPE%[ADDR]
B$=" "
C1=C
C2=1
IF BP%[ADDR]==1 THEN B$="":SWAP C1,C2
IF BP%[ADDR]==2 THEN B$=""
LOCATE 0,Y
COLOR C1,C2
PRINT F16(ADDR);
'PDATA ADDR,B$,0,Y,C1,C2,C1,C2
PDATA DAT,B$,5,Y,C1,C2,C1,C2
COLOR C,1
IF MBIN THEN
MEC$=BIN$(R(DAT),16)
FOR MCB=0 TO 15
IF MEC$[MCB]=="0" THEN MEC$[MCB]=""
IF MEC$[MCB]=="1" THEN MEC$[MCB]=""
NEXT
PRINT MEC$;'"";
ENDIF

IF MBIN THEN PRINT ""; ELSE PRINT " ";
IF LEN(LVIEW(ADDR))>0 THEN
COLOR 1,C
'PRINT LVIEW2(ADDR);
TRUNCPRINT LVIEW2(ADDR),50-CSRX
COLOR C,1
PRINT " ";
ENDIF
COLOR C,1
'PRINT D1(ADDR,TY);

IF CSRX!=50 THEN SOURCEPRINT ADDR,50-CSRX
END


DEF MPUCONFIG
WHILE 1
DISPLAY 0
COLOR 15,1
CLS
DISPLAY 1
COLOR 15,1
CLS
PRINT "";
IF MBIN THEN COLOR 15,1:PRINT "BIN:ON"; ELSE COLOR 14,1:PRINT "BIN:OFF";
COLOR 15,1
PRINT "";
IF LPM THEN COLOR 15,1 ELSE COLOR 14,1
PRINT "PD:";MPD;
COLOR 15,1
PRINT "";
IF HEX THEN PRINT "HEX" ELSE PRINT "DEC"
PRINT
PRINT "BREAKPOINT TOOLS"
PRINT "LABEL BROWSER"
IF RFVSYNC THEN COLOR 15,1 ELSE COLOR 14,1
PRINT "REFRESH DELAY:";
PRINT RFVSYNC
BTN=GETBTN()

IF BTN==#X THEN BREAK
IF BTN==#A THEN MBIN=1-MBIN
IF BTN==#B THEN MPD=DMGETNUM("MEMPEEK POINTER DEPTH",MPD)
IF BTN==#Y THEN HEX=1-HEX
IF BTN==#UP THEN BKPU
IF BTN==#DOWN THEN LPU
IF BTN==#RIGHT THEN RFVSYNC=DMGETNUM("REFRESH DELAY",RFVSYNC)
WEND
RESET
END


'RETURNS THE LABEL OF AN ADDRESS, RETURNS AN EMPTY STRING IF NONE IS FOUND
DEF LVIEW(MEM)
RETURN LABEL$[R(MEM),0]
END

DEF LVIEW2(MEM)
RETURN$=""
IF LEN(LABEL$[R(MEM),0])>0 THEN
IF LABEL$[R(MEM),1]=="G" THEN INC RETURN$,":"
IF LABEL$[R(MEM),1]=="L" THEN INC RETURN$,">"

INC RETURN$,LABEL$[R(MEM),0]+" #"+LABEL$[R(MEM),2]
ENDIF
RETURN RETURN$
END



DEF RA(N%)'REGISTER ACCESS

IF N%<&H10 THEN RETURN REG%[N%]
IF N%<=&H1F THEN RETURN VPOP(N%-&H10)
IF N%<=&H2F THEN RETURN RM(REG%[N%-&H20])
IF N%<=&H3F THEN RETURN RM(REG%[11]+(N%-&H30))
IF N%<=&H4F THEN REG%[N%-&H40]=R(REG%[N%-&H40]-1):RETURN R(REG%[N%-&H40]+1)
IF N%<=&H5F THEN REG%[N%-&H50]=R(REG%[N%-&H50]+1):RETURN R(REG%[N%-&H50]-1)

IF N%<=&H6F THEN REG%[N%-&H60]=R(REG%[N%-&H60]-1):RETURN REG%[N%-&H60]
IF N%<=&H7F THEN REG%[N%-&H70]=R(REG%[N%-&H70]+1):RETURN REG%[N%-&H70]
IF N%<=&H8F THEN RETURN R(NOT(REG%[N%-&H80]))


IF N%==&H90 THEN RETURN 0
IF N%>=&H91 THEN RETURN RM(N%)

END

DEF RS D%,N%'REGISTER SET

IF N%<&H10 THEN REG%[N%]=R(D%):RETURN
IF N%<=&H1F THEN VPUSH R(D%),N%-&H10:RETURN
IF N%<=&H2F THEN WM R(D%),REG%[N%-&H20]:RETURN
IF N%<=&H3F THEN WM R(D%),REG%[11]+(N%-&H30):RETURN

IF N%<=&H4F THEN REG%[N%-&H40]=R(D%-1):RETURN
IF N%<=&H5F THEN REG%[N%-&H50]=R(D%+1):RETURN

IF N%<=&H8F AND N%>=&H80 THEN REG%[N%-&H80]=R(NOT(D%))
IF N%>=&H91 THEN WM R(D%),N%:RETURN
END






DEF NAMESRC(N)
N$=""
FOR I=0 TO 13
C$=CHR$(RM(N+I))
IF INSTR("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-@_.0123456789",C$)<0 THEN BREAK
N$=N$+C$
NEXT
IF N$=="" THEN N$=""
RETURN N$
END

DEF VPUSH N%,S% 'PUSH TO VIRTUAL STACK
POINTER=RA(S%)
RS POINTER-1,S%
WM N%,POINTER-1
END

DEF VPOP(S%) 'POP FROM VIRTUAL STACK
POINTER%=RA(S%)
VALUE%=RM(POINTER%)
RS POINTER%+1,S%
RETURN VALUE%
END

DEF VIPUSH N,S 'PUSH TO INVERTED VIRTUAL STACK
POINTER=RA(S)
RS POINTER+1,S
WM N,POINTER+1
END

DEF VIPOP(S) 'POP FROM INVERTED VIRTUAL STACK
POINTER=RA(S)
VALUE=RM(POINTER)
RS POINTER-1,S
RETURN VALUE
END



DEF TRUNCPRINT T$,L 'PRINT TO LENGTH, TRUNCATING IF NEEDED

IF LEN(T$)<L THEN
PRINT T$; ELSE
PRINT LEFT$(T$,L-1);"…";
'COLOR 0,15
'PRINT T$[L-1];
ENDIF
END

























'MACHINE INSTRUCTIONS
@OP0
GOTO @HALT
RETURN

@OP1 'MOVE
RS ARG%[0],ARG%[1]
RETURN

@OP2'COPY
RS RA(ARG%[0]),ARG%[1]
RETURN

@OP3'SWAP
V1=RA(ARG%[0])
V2=RA(ARG%[1])
RS V1,ARG%[1]
RS V2,ARG%[0]
RETURN

@OP4'JUMP
RS ARG%[0],15
RETURN

@OP5'REFR
REFRESH
RETURN

@OP6'VSYNCI
WAIT ARG%[0]
RETURN

@OP7'VSYNCR
WAIT RA(ARG%[0])
RETURN

@OP8'DEC
RS RA(ARG%[0])-1,ARG%[0]
RETURN

@OP9'INC
RS RA(ARG%[0])+1,ARG%[0]
RETURN

@OP10'COMPILE
LNAME$=NAMESRC(RA(ARG%[0]))
START=RA(ARG%[1])
LWORD=ARG%[2]
RESULTREG=ARG%[3]

IF LNAME$=="" THEN REST=0:GOTO @OP10B
IF LNAME$ THEN LOAD "PRG2:"+LNAME$,FALSE
REST=RESULT
@OP10B
IF REST THEN
INC CNUM
RS COMPILE(START,2,0,0),LWORD';@:;@:
RS REST,RESULTREG
ELSE
RS 0,LWORD
RS REST,RESULTREG
ENDIF

RETURN

@OP11'LOAD
DISPLAY 0
COLOR 15,0
LOCATE 49,0
PRINT "";
LNAME$=NAMESRC(RA(ARG%[0]))
OFFSET=RA(ARG%[1])
LWORD=ARG%[2]
RESULTREG=ARG%[3]

TEXT$=""
IF LNAME$=="" THEN REST=0:GOTO @OP11B
IF LNAME$ THEN LOAD "TXT:"+LNAME$,FALSE OUT TEXT$
REST=RESULT
@OP11B
FOR I=0 TO LEN(TEXT$)-1
LT ASC(TEXT$[I]),I+OFFSET
NEXT
RS I+OFFSET,LWORD
RS REST,RESULTREG
LOCATE 49,0
PRINT " ";
RETURN

@OP12'DATASAVE
DISPLAY 0
COLOR 15,0
LOCATE 49,0
PRINT "";
START=RA(ARG%[0])
FINISH=START+RA(ARG%[1])-1
LNAME$=NAMESRC(RA(ARG%[2]))
RESULTREG=ARG%[3]

FILE$=""

FOR I=START TO FINISH
FILE$=FILE$+STR$(RM(I))+CHR$(10)
NEXT
IF LNAME$!="" THEN SAVE "TXT:"+LNAME$,FILE$
RS RESULT,RESULTREG
LOCATE 49,0
PRINT " ";
RETURN

@OP13'SAVE
DISPLAY 0
COLOR 15,0
LOCATE 49,0
PRINT "";
START=RA(ARG%[0])
FINISH=START+RA(ARG%[1])-1
LNAME$=NAMESRC(RA(ARG%[2]))
RESULTREG=ARG%[3]
FILE$=""

FOR I=START TO FINISH
FILE$=FILE$+CHR$(RM(I))
NEXT
LNAME$=NAMESRC(RA(ARG%[2]))
IF LNAME$!="" THEN SAVE "TXT:"+LNAME$,FILE$
RS RESULT,RESULTREG
LOCATE 49,0
PRINT " ";
RETURN


@OP14'LOADR
RS RM(RA(ARG%[0])),ARG%[1]
RETURN

@OP15'LOADM
RS RM(ARG%[0]),ARG%[1]
RETURN

@OP16'ILOADR
RS RM(ARG%[0]+RA(ARG%[1])),ARG%[2]
RETURN

@OP17'RLOADR
RS RM(RA(ARG%[1])+RA(ARG%[0])),ARG%[2]
RETURN

@OP18'STORER
WRITE%=RA(ARG%[0])
WM WRITE%,RA(ARG%[1])
RETURN

@OP19'STOREM
WM RA(ARG%[0]),ARG%[1]
RETURN

@OP20'ISTORER
WRITE%=RA(ARG%[0])
WM WRITE%,RA(ARG%[1])+ARG%[2]
RETURN

@OP21'RSTORER
WRITE%=RA(ARG%[0])
WM WRITE%,RA(ARG%[2])+RA(ARG%[1])
RETURN

@OP22'ADDR
ANSWER%=RA(ARG%[1])+RA(ARG%[0])
RF=ANSWER%>>16
RS ANSWER%,ARG%[2]
RS RF,ARG%[3]
RETURN

@OP23'ADDI
ANSWER%=RA(ARG%[1])+ARG%[0]
RF=ANSWER%>>16
RS ANSWER%,ARG%[2]
RS RF,ARG%[3]
RETURN

@OP24'SUBR
OP%=RA(ARG%[0])
ANSWER%=RA(ARG%[1])-OP%
RF=R(SGN(ANSWER%)) AND 2
RS ANSWER%,ARG%[2]
RS RF>>1,ARG%[3]
RETURN

@OP25'SUBI
ANSWER%=RA(ARG%[1])-ARG%[0]
RF=R(SGN(ANSWER%)) AND 2
RS ANSWER%,ARG%[2]
RS RF>>1,ARG%[3]
RETURN

@OP26'MULR
ANSWER=RA(ARG%[1])*RA(ARG%[0])
RS ANSWER>>16,ARG%[2]
RS ANSWER,ARG%[3]
RETURN

@OP27'MULI
ANSWER=RA(ARG%[1])*ARG%[0]
RS ANSWER>>16,ARG%[2]
RS ANSWER,ARG%[3]
RETURN

@OP28'DIVR
DIVISOR=RA(ARG%[0])
DIVIDEND=RA(ARG%[1])
IF DIVISOR==0 THEN
RS 0,ARG%[2]
RS 0,ARG%[3]
ELSE
REMAINDER=DIVIDEND MOD DIVISOR
QUOTIENT=DIVIDEND DIV DIVISOR
RS REMAINDER,ARG%[2]
RS QUOTIENT,ARG%[3]
ENDIF
RETURN

@OP29'DIVI
DIVISOR=ARG%[0]
DIVIDEND=RA(ARG%[1])
IF DIVISOR==0 THEN
RS 0,ARG%[2]
RS 0,ARG%[3]
ELSE
REMAINDER=DIVIDEND MOD DIVISOR
QUOTIENT=DIVIDEND DIV DIVISOR
RS REMAINDER,ARG%[2]
RS QUOTIENT,ARG%[3]
ENDIF
RETURN

@OP30'TWO
RS R(-RA(ARG%[0])),ARG%[1]
RETURN

@OP31'ANDR
RS RA(ARG%[1]) AND RA(ARG%[0]),ARG%[2]
RETURN

@OP32'ANDI
RS RA(ARG%[1]) AND ARG%[0],ARG%[2]
RETURN

@OP33'ORR
RS RA(ARG%[1]) OR RA(ARG%[0]),ARG%[2]
RETURN

@OP34'ORI
RS RA(ARG%[1]) OR ARG%[0],ARG%[2]
RETURN

@OP35'XORR
RS RA(ARG%[1]) XOR RA(ARG%[0]),ARG%[2]
RETURN

@OP36'XORI
RS RA(ARG%[1]) XOR ARG%[0],ARG%[2]
RETURN

@OP37'NOT
RS NOT RA(ARG%[0]),ARG%[1]
RETURN

@OP38'LEFTR
SHIFTBY=RA(ARG%[0])
SHIFTNUM=RA(ARG%[1])

SHIFTED=SHIFTNUM<<SHIFTBY
OVERFLOW=SHIFTED>>16

RS SHIFTED,ARG%[2]
RS OVERFLOW,ARG%[3]
RETURN

@OP39'LEFTI
SHIFTBY=ARG%[0]
SHIFTNUM=RA(ARG%[1])

SHIFTED=SHIFTNUM<<SHIFTBY
OVERFLOW=SHIFTED>>16

RS SHIFTED,ARG%[2]
RS OVERFLOW,ARG%[3]
RETURN

@OP40'RIGHTR
SHIFTBY=RA(ARG%[0])
SHIFTNUM=RA(ARG%[1])

SHIFTED=SHIFTNUM>>SHIFTBY
MASK=&H7FFFFFFF>>(SHIFTBY-1)
OVERFLOW=((SHIFTNUM<<16)>>SHIFTBY) AND MASK

RS SHIFTED,ARG%[2]
RS OVERFLOW,ARG%[3]
RETURN

@OP41'RIGHTI
SHIFTBY=ARG%[0]
SHIFTNUM=RA(ARG%[1])

SHIFTED=SHIFTNUM>>SHIFTBY
MASK=&H7FFFFFFF>>(SHIFTBY-1)
OVERFLOW=((SHIFTNUM<<16)>>SHIFTBY) AND MASK

RS SHIFTED,ARG%[2]
RS OVERFLOW,ARG%[3]
RETURN

@OP42'TRUE
IF RA(ARG%[0])!=0 THEN RS 1,ARG%[1] ELSE RS 0,ARG%[1]
RETURN

@OP43 'SIGN R1 R2
NUM%=RA(ARG%[0])
IF NUM% AND &H8000 THEN RS -1,ARG%[1] ELSE IF NUM% THEN RS 1,ARG%[1] ELSE RS 0,ARG%[1]
RETURN

@OP44'RND
RS RND(65536),ARG%[0]
RETURN

@OP45'TOUCH
TOUCH OUT S,X,Y
RS X,ARG%[0]
RS Y,ARG%[1]
RS S,ARG%[2]
RETURN

@OP46'CLIPR
CHR%=RA(ARG%[0])
IF CHR%>=LEN(CLP$) THEN RS 0,ARG%[1] ELSE RS ASC(CLP$[CHR%]),ARG%[1]
RETURN

@OP47'CLIPI
IF ARG%[0]>=LEN(CLP$) THEN RS 0,ARG%[1] ELSE RS ASC(CLP$[ARG%[0]]),ARG%[1]
RETURN

@OP48'CLIPL
RS LEN(CLP$),ARG%[0]
RETURN

@OP49'BUTTON
RS BUTTON(0),ARG%[0]
RETURN

@OP50'MIL
ANSWER=MILLISEC
RS ANSWER>>16,ARG%[0]
RS ANSWER,ARG%[1]
RETURN

@OP51'TIME
HOUR=VAL(MID$(TIME$,0,2))
MINUTE=VAL(MID$(TIME$,3,2))
SECOND=VAL(MID$(TIME$,6,2))
RS HOUR,ARG%[0]
RS MINUTE,ARG%[1]
RS SECOND,ARG%[2]
RETURN

@OP52'DATE
YEAR=VAL(MID$(DATE$,0,4))
MONTH=VAL(MID$(DATE$,5,2))
DAY=VAL(MID$(DATE$,8,2))
RS YEAR,ARG%[0]
RS MONTH,ARG%[1]
RS DAY,ARG%[2]
RETURN

@OP53'OUT
INC OUT$,CHR$(RA(ARG%[0]))
RETURN

@OP54'BEEP
INSTRUMENT=RA(ARG%[0])
PITCH=RA(ARG%[1])
IF INSTRUMENT<134 THEN
IF PITCH>&H7FFF THEN PITCH=PITCH-&H10000
BEEP INSTRUMENT,PITCH
ENDIF
RETURN


@OP55'JER
IF RA(ARG%[1])==RA(ARG%[0]) THEN RS ARG%[2],15
RETURN

@OP56'JEI
IF ARG%[0]==RA(ARG%[1]) THEN RS ARG%[2],15
RETURN

@OP57'JNR
IF RA(ARG%[1])!=RA(ARG%[0]) THEN RS ARG%[2],15
RETURN

@OP58'JNI
IF ARG%[0]!=RA(ARG%[1]) THEN RS ARG%[2],15
RETURN

@OP59'JGR+
IF RA(ARG%[1])<RA(ARG%[0]) THEN RS ARG%[2],15
RETURN

@OP60'JGR-
IF R(RA(ARG%[1])+&H8000)<R(RA(ARG%[0])+&H8000) THEN RS ARG%[2],15
RETURN

@OP61'JGI+
IF ARG%[0]>RA(ARG%[1]) THEN RS ARG%[2],15
RETURN

@OP62'JGI-
IF R(ARG%[0]+&H8000)>R(RA(ARG%[1])+&H8000) THEN RS ARG%[2],15
RETURN

@OP63'JLR+
IF RA(ARG%[1])>RA(ARG%[0]) THEN RS ARG%[2],15
RETURN

@OP64'JLR-
IF R(RA(ARG%[1])+&H8000)>R(RA(ARG%[0])+&H8000) THEN RS ARG%[2],15
RETURN

@OP65'JLI+
IF ARG%[0]<RA(ARG%[1]) THEN RS ARG%[2],15
RETURN

@OP66'JLI-
IF R(ARG%[0]+&H8000)<R(RA(ARG%[1])+&H8000) THEN RS ARG%[2],15
RETURN

@OP67'FORKR+
COMP%=RA(ARG%[1])-RA(ARG%[0])
IF SGN(COMP%)==1 THEN RS ARG%[2],15
IF SGN(COMP%)==-1 THEN RS ARG%[3],15
RETURN

@OP68'FORKR-
COMP%=R(RA(ARG%[1])+&H8000)-R(RA(ARG%[0])+&H8000)
IF SGN(COMP%)==1 THEN RS ARG%[2],15
IF SGN(COMP%)==-1 THEN RS ARG%[3],15
RETURN

@OP69'FORKI+
COMP%=RA(ARG%[1])-ARG%[0]
IF SGN(COMP%)==1 THEN RS ARG%[2],15
IF SGN(COMP%)==-1 THEN RS ARG%[3],15
RETURN

@OP70'FORKI-
COMP%=R(RA(ARG%[1])+&H8000)-R(ARG%[0]+&H8000)
IF SGN(COMP%)==1 THEN RS ARG%[2],15
IF SGN(COMP%)==-1 THEN RS ARG%[3],15
RETURN

@OP71'PUSHR
VPUSH RA(ARG%[0]),ARG%[1]
RETURN

@OP72'PUSHI
VPUSH ARG%[0],ARG%[1]
RETURN

@OP73'POP
RS VPOP(ARG%[0]),ARG%[1]
RETURN

@OP74'R
VPUSH RA(ARG%[0]),11
RETURN

@OP75'I
VPUSH ARG%[0],11
RETURN

@OP76'G
RS VPOP(11),ARG%[0]
RETURN

@OP77'PSR
IF DEBUG% THEN PUSH RU%,1<<ARG%[0]
VPUSH RA(ARG%[0]),12
RETURN

@OP78'RSR
IF DEBUG% THEN IF LEN(RU%)>0 THEN TEMP=POP(RU%)
RS VPOP(12),ARG%[0]
RETURN

@OP79'S
FOR P=0 TO 15
IF (ARG%[0] AND 1<<P) THEN VPUSH REG%[P],11
NEXT
RETURN

@OP80'REC
FOR P=15 TO 0 STEP -1
IF (ARG%[0] AND 1<<P) THEN REG%[P]=VPOP(11)
NEXT
RETURN

@OP81'PE
IF DEBUG% THEN PUSH RU%,ARG%[0]
FOR P=0 TO 15
IF (ARG%[0] AND 1<<P) THEN VPUSH REG%[P],12
NEXT
RETURN

@OP82'RE
IF DEBUG% THEN IF LEN(RU%)>0 THEN TEMP=POP(RU%)
FOR P=15 TO 0 STEP -1
IF (ARG%[0] AND 1<<P) THEN REG%[P]=VPOP(12)
NEXT
RETURN

@OP83'PR
IF DEBUG% THEN PUSH RU%,ARG%[0]
FOR P=0 TO 15
IF (ARG%[0] AND 1<<P) THEN VPUSH REG%[P],12
NEXT
FOR P=15 TO 0 STEP -1
IF (ARG%[1] AND 1<<P) THEN REG%[P]=VPOP(11)
NEXT
RETURN

@OP84'SR
FOR P=0 TO 15
IF (ARG%[0] AND 1<<P) THEN VPUSH REG%[P],11
NEXT
IF DEBUG% THEN IF LEN(RU%)>0 THEN TEMP=POP(RU%)
FOR P=15 TO 0 STEP -1
IF (ARG%[1] AND 1<<P) THEN REG%[P]=VPOP(12)
NEXT
RETURN

@OP85'[
IF DEBUG% THEN PUSH DSTACK%,ARG%[0]:PUSH SSTACK%,REG%[15]
VPUSH REG%[15],12
RS ARG%[0],15
RETURN

@OP86']
IF DEBUG% THEN IF LEN(DSTACK%)>0 THEN TEMP=POP(DSTACK%):TEMP=POP(SSTACK%)
RS VPOP(12),15
RETURN

@OP87'EXIT
IF DEBUG% THEN IF LEN(DSTACK%)>0 THEN TEMP=POP(DSTACK%):TEMP=POP(SSTACK%)

IF DEBUG% THEN IF LEN(RU%)>0 THEN TEMP=POP(RU%)
FOR P=15 TO 0 STEP -1
IF (ARG%[0] AND 1<<P) THEN REG%[P]=VPOP(12)
NEXT

RS VPOP(12),15
RETURN

@OP88'FUNC
FOR P=0 TO 15
IF (ARG%[0] AND 1<<P) THEN VPUSH REG%[P],11
NEXT

IF DEBUG% THEN PUSH DSTACK%,ARG%[1]:PUSH SSTACK%,REG%[15]
VPUSH REG%[15],12
RS ARG%[1],15
RETURN

@OP89'SRE
FOR P=0 TO 15
IF (ARG%[0] AND 1<<P) THEN VPUSH REG%[P],11
NEXT
IF DEBUG% THEN IF LEN(RU%)>0 THEN TEMP=POP(RU%)
FOR P=15 TO 0 STEP -1
IF (ARG%[1] AND 1<<P) THEN REG%[P]=VPOP(12)
NEXT
IF DEBUG% THEN IF LEN(DSTACK%)>0 THEN TEMP=POP(DSTACK%):TEMP=POP(SSTACK%)
RS VPOP(12),15
RETURN

@OP90'STOREIR
WM ARG%[0],RA(ARG%[1])
RETURN

@OP91'STOREIM
WM ARG%[0],ARG%[1]
RETURN

@OP92'SDIVR
DIVISOR=RA(ARG%[0])
DIVIDEND=RA(ARG%[1])

DIVISOR=DIVISOR-2*(DIVISOR AND &H8000)
DIVIDEND=DIVIDEND-2*(DIVIDEND AND &H8000)

IF DIVISOR==0 THEN
RS 0,ARG%[2]
RS 0,ARG%[3]
ELSE
REMAINDER=DIVIDEND MOD DIVISOR
QUOTIENT=DIVIDEND DIV DIVISOR
RS REMAINDER,ARG%[2]
RS QUOTIENT,ARG%[3]
ENDIF
RETURN

@OP93'SDIVI
DIVISOR=ARG%[0]
DIVIDEND=RA(ARG%[1])

DIVISOR=DIVISOR-2*(DIVISOR AND &H8000)
DIVIDEND=DIVIDEND-2*(DIVIDEND AND &H8000)

IF DIVISOR==0 THEN
RS 0,ARG%[2]
RS 0,ARG%[3]
ELSE
REMAINDER=DIVIDEND MOD DIVISOR
QUOTIENT=DIVIDEND DIV DIVISOR
RS REMAINDER,ARG%[2]
RS QUOTIENT,ARG%[3]
ENDIF
RETURN

@OP94 'ROLR
ROLBY=(RA(ARG%[0]) MOD 16) AND &HF
ROLNUM=RA(ARG%[1])

ROTATED=(ROLNUM<<ROLBY)OR(ROLNUM<<ROLBY)>>16

RS ROTATED,ARG%[2]
RETURN

@OP95 'ROLI
ROLBY=(ARG%[0] MOD 16) AND &HF
ROLNUM=RA(ARG%[1])

ROTATED=(ROLNUM<<ROLBY)OR(ROLNUM<<ROLBY)>>16

RS ROTATED,ARG%[2]
RETURN

@OP96 'RORR
ROLBY=(-RA(ARG%[0]) MOD 16) AND &HF
ROLNUM=RA(ARG%[1])

ROTATED=(ROLNUM<<ROLBY)OR(ROLNUM<<ROLBY)>>16

RS ROTATED,ARG%[2]
RETURN

@OP97 'RORI
ROLBY=(-ARG%[0] MOD 16) AND &HF
ROLNUM=RA(ARG%[1])

ROTATED=(ROLNUM<<ROLBY)OR(ROLNUM<<ROLBY)>>16

RS ROTATED,ARG%[2]
RETURN

@OP98 'JAR
OP1=RA(ARG%[0])
OP2=RA(ARG%[1])
IF OP1 AND OP2 THEN RS ARG%[2],15
RETURN

@OP99 'JAI
OP1=ARG%[0]
OP2=RA(ARG%[1])
IF OP1 AND OP2 THEN RS ARG%[2],15
RETURN

@OP100 'DECODE
RS 1<<RA(ARG%[0]),ARG%[1]
RETURN

@OP101 'MCOPYR
L1=RA(ARG%[0])
LENGTH=RA(ARG%[1])<<16>>16
L2=RA(ARG%[2])
IF LENGTH<0 THEN BIAS=1 ELSE BIAS=0
IF LENGTH==0 THEN RETURN
FOR I=0 TO (ABS(LENGTH)-1)*SGN(LENGTH) STEP SGN(LENGTH+0.1)
WM RM(L1+I-BIAS),L2+I-BIAS
NEXT
RETURN

@OP102 'MCOPYI
L1=ARG%[0]
LENGTH=RA(ARG%[1])<<16>>16
L2=RA(ARG%[2])
IF LENGTH<0 THEN BIAS=1 ELSE BIAS=0
IF LENGTH==0 THEN RETURN
FOR I=0 TO (ABS(LENGTH)-1)*SGN(LENGTH) STEP SGN(LENGTH+0.1)
WM RM(L1+I-BIAS),L2+I-BIAS
NEXT
RETURN

@OP103 'MFILLR
LOC=RA(ARG%[0])
LENGTH=RA(ARG%[1])
BYTE=RA(ARG%[2])

FOR I=0 TO LENGTH-1
WM BYTE,LOC+I
NEXT
RETURN


@OP104 'MFILLI
LOC=ARG%[0]
LENGTH=RA(ARG%[1])
BYTE=RA(ARG%[2])

FOR I=0 TO LENGTH-1
WM BYTE,LOC+I
NEXT
RETURN

@DEX 'DIRECT EXECUTION
IF DEBUG% THEN PUSH DSTACK%,CI%:PUSH SSTACK%,REG%[15]
VPUSH REG%[15],12
RS CI%,15
RETURN

