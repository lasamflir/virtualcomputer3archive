'BF INTERPRETER WITH OPTIMSATION

'READ IN PROGRAM TERMINATED BY !

'TO OPTIMISE OUT SHORT LOOPS
'[-] [+] [<] [>]

'WHEN A [ IS READ, READ *AHEAD* TO FIND OUT IF IT IS A SHORT LOOP AND WRITE IT OUT AS *, ( OR ). IF NOT A SHORT LOOP, JUST WRITE [

'"VALIDR" IS FOR REPEATING INSTRUCTIONS

*&H100
MOVE <BMAP 14

'R0=CLIPBOARD POINTER
MOVE <BFCODE 1 'R1=MEMORY POINTER
COPY 1 13

'READ PROGRAM FROM CLIPBOARD
>READLOOP
CLIPR )0 2 'GET PROGRAM CHARACTER
REFR
JEI 0 2 <READEND 'DETECT END OF CLIPBOARD

'VALID CHARACTERS, SORTED BY FREQUENCY.
JEI !> 2 <VALIDR '>
JEI !< 2 <VALIDR '<
JEI !+ 2 <VALIDR '+
JEI !- 2 <VALIDR '-
JEI ![ 2 <VALID[ '[
JEI !] 2 <VALID  ']
JEI !. 2 <VALID  '.
JEI !, 2 <VALID  ',

'EXCLAMATION POINT (PROGRAM/INPUT SEPARATOR)
JEI !! 2 <READEND '!

'IT'S NOT A VALID CHARACTER, FETCH NEXT ONE.
JUMP <READLOOP

>VALID
STORER 2 )1 'WRITE OUT TO MEMORY
JUMP <READLOOP

>VALIDR
ILOADR -2 1 3 'GET LAST CHARACTER
JER 2 3 <REPEATED 'REPEATED?

STORER 2 )1 'WRITE OUT TO MEMORY
INC ,1 'INCREMENT RCOUNT
INC 1
JUMP <READLOOP

>REPEATED
DEC 1 'MOVE BACK TO REPCOUNT
INC .1 'INCREMENT IT
INC 1 'MOVE BACK TO EMPTY SPACE
JUMP <READLOOP

>VALID[

'READ TWO CHARACTERS AHEAD
ADDI 1 0 4 % 'R4=NEXT POSITION
CLIPR 4 = 'GET LAST CHARACTER
JEI !! 4 <READEND 'END?
JNI !] 4 <VALID 'NOT SHORT LOOP?

'READ MIDDLE LOOP CHARACTER
CLIPR 0 3 'GET CHR
JEI !! 3 <READEND 'END?
JEI ![ 3 <VALID 'LOOP?
JEI !] 3 <VALID 'LOOP?
JEI !. 3 <VALID 'LOOP?
JEI !, 3 <VALID 'LOOP?

R 3 'SEND CHR
I <BFI 'BF INSTRUCTION TABLE
I <OI 'OPTIMISED INSTRUCTION TABLE
;@SWAPTABLE
G ,1 'GET CHR
INC 1 'ADVANCE POINTER
INC )0 'ADVANCE CLIPBOARD POINTER
JUMP <READLOOP

>READEND
PSR 0 'PRESERVE CLIPBOARD POINTER
MOVE <BFCODE 0 'R0=POINTER

REFR

>BLOOP
JEI !] ,0 <B] 'CLOSING BRACKET?
JEI ![ ,0 <B[ 'OPENING BRACKET?

>BCONT
'ADVANCE POINTER
R ,0
I <CAT 'CHARACTER ADVANCE TABLE
I <GAP '"GAPS"
;@SWAPTABLE
ADDR .11 0 = % 'ADVANCE POINTER
JEI 0 ,0 <BEXIT 'START INTERPTER?
JUMP <BLOOP

>B[
R 0 'PUSH LOCATION
JUMP <BCONT

>B]
G 2 'POP LOCATION
ISTORER 2 0 &H1000 'STORE BRACKET
ISTORER 0 2 &H1000 'STORE BRACKET
REFR
JUMP <BCONT

>BEXIT
MOVE ;LIB_END 13 'PUT OUTPUT ON SCREEN
MOVE <DP_START 14
MOVE <BFCODE 0 'R0=PC
MOVE <DP_START 1 'R1=DP
RSR 2 'R2=CLIPBOARD POINTER
MOVE 1 3 'R3=REFRESH FLAG

>ILOOP
BUTTON 7
JEI #A 7 <A 'SWITCH OFF REFRESH
JEI #B 7 <B 'SWITCH ON REFRESH
JEI 0 6 <SKIPRF 'SKIP REFRESH
<REFRESH

>SKIPRF
JEI !> ,0 <INCP
JEI !< ,0 <DECP
JEI !+ ,0 <INCC
JEI !- ,0 <DECC
JEI ![ ,0 <OPEN
JEI !] ,0 <CLOSE
JEI !) ,0 <NEXT
JEI !( ,0 <PREV
JEI !* ,0 <ZERO
JEI !. ,0 <OUT
JEI !, ,0 <IN
JEI 0 ,0 <HALT

>RET
INC 0 'INC IP
JUMP <ILOOP

>INCP
INC 0 'INC IP
ADDR ,0 1 = % 'ADVANCE POINTER
JUMP <RET

>DECP
INC 0 'INC IP
SUBR ,0 1 = % 'ADVANCE POINTER
JUMP <RET

>INCC
INC 0 'INC IP
ADDR ,0 ,1 = % 'ADD TO CELL
JUMP <RET

>DECC
INC 0 'INC IP
SUBR ,0 ,1 = % 'SUB CELL
JUMP <RET

>OPEN
JNI 0 ,1 <RET 'NOP IF CELL IS NONZERO
ILOADR &H1000 0 = 'GET NEW PC
JUMP <RET

>CLOSE
JEI 0 ,1 <RET 'NOP IF CELL IS ZERO
ILOADR &H1000 0 = 'GET NEW PC
JUMP <RET

>NEXT
JEI 0 ,1 <RET 'NOP IF CELL IS ZERO
INC 1 'MOVE RIGHT
JUMP <NEXT

>PREV
JEI 0 ,1 <RET 'NOP IF CELL IS ZERO
DEC 1 'MOVE LEFT
JUMP <PREV

>ZERO '[-]
STOREIR 0 1 'RESET CELL
JUMP <RET

>OUT
R ,1 'PUSH OUTPUT
;@PC 'PRINT
<REFRESH
JUMP <RET

>IN
CLIPR 2 ,1 'GET INPUT, TREATING EOF AS ZERO
INC 2 'ADVANCE CLIPBOARD POINTER
<REFRESH
JUMP <RET

>HALT
HALT

>REFRESH
COPY 1 8 'COPY DP
SUBI <DP_START 8 = % 'SUBTRACT START
DIVI &H300 8 = = 'DIVIDE DOWN
MULI &H300 8 = = 'MULTIPLY OUT
ADDI <DP_START 8 = % 'ADD START
COPY 8 14 'PUT ON LOWER SCREEN
REFR
]

>A
MOVE 0 6 'RESET REFRESH FLAG
JUMP <ILOOP

>B
MOVE 1 6 'SET REFRESH FLAG
JUMP <ILOOP

>BFI 'BF INSTRUCTIONS
$-+<>

>OI 'OPTIMISED INSTRUCTIONS
$**()

>CAT
$+-<>[],.()*

>GAP
2 2 2 2 1 1 1 1 1 1 1

+2 'BUFFER
>BFCODE 'OPTIMISED CODE
+&H1000

>BMAP 'BRACKET MAP
+&H1000

>DP_START 'MEMORY

